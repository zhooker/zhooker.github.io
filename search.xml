<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[EditText 限制输入字符个数的三种方式]]></title>
    <url>%2F2018%2F12%2F26%2FEditText-%E9%99%90%E5%88%B6%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近有个需求是限制用户输入的字符个数，其中中文算2个，非中文字符算1个，比如“1个人”就算5个，当用户输入超过字数限制的时候可以截取并用toast提示用户，这是个非常简单的需求，实现也有很多方法。 首先我们实现检测中文的方法，网上有很多方式，主要是检测字符的unicode值范围：123fun isChinese(c: Char): Boolean &#123; return c.toInt() in 0x4E00..0x9FA5&#125; 如果是中文就算2个，否则算1个，函数实现如下：1fun getCharTextCount(c: Char) = if (Utils.isChinese(c)) 2 else 1 根据上面的规则，检测一个字符串的字数的函数实现如下：123456789101112131415/** * 计算字符串的长度，中文加2，非中文加1 */@JvmStaticfun calcTextLength(charSequence: CharSequence?): Int &#123; if (charSequence.isNullOrEmpty()) &#123; return 0; &#125; var sum = 0 for (c in charSequence) &#123; sum += Utils.getCharTextCount(c) &#125; return sum&#125; 这部分代码在Utils.java中，作为项目的函数工具类。下面列举各种实现方式并做对比。 1、使用InputFilter 限制字数实现InputFilter过滤器， 需要覆盖一个叫filter的方法。12345678public abstract CharSequence filter ( CharSequence source, //输入的文字 int start, //输入的文字 开始位置 int end, //输入的文字 结束位置 Spanned dest, //当前显示的内容 int dstart, //当前显示的内容 开始位置 int dend //当前显示的内容 结束位置 ); 一开始看这个filter函数，参数比较多，意思也比较相近，可能容易搞混，但是当你注意每个参数的含义后，会很好理解，其实就是”将dest中范围为dstart到dend的用source的start到end范围的替换”。接下来实现这个函数：1234567891011121314151617181920212223242526272829class TextLengthFilter(private val maxLength: Int = Utils.MAX_LENGTH, val listener: TextLengthListener? = null) : InputFilter &#123; override fun filter( source: CharSequence?, start: Int, end: Int, dest: Spanned?, dstart: Int, dend: Int ): CharSequence &#123; if (source.isNullOrEmpty()) &#123; return "" &#125; // bug fixed. // val source: CharSequence = source.subSequence(start, end) var sum = Utils.calcTextLength(dest as CharSequence, dstart, dend) + Utils.calcTextLength(source) - maxLength if (sum &gt; 0) &#123; val delete = Utils.getDeleteIndex(source, 0, source.length, sum) listener?.onTextLengthOutOfLimit() // 输入字符超过了限制，截取 return if (delete &gt; 0) source.subSequence(0, delete) else "" &#125; // 没有超过限制，直接返回source return source &#125;&#125; 我们用Utils.calcTextLength(source: CharSequence, dstart: Int, dend: Int)来计算字符串除了[dstart,dend]外的字符数，因为通过上面的分析可知 [dstart,dend]范围内的字符是会被替换的，所以不需要计算总字数内。在代码中添加InputFilter监听即可实现功能 ：1edit_inputfilter.filters = arrayOf(TextLengthFilter(listener = MainActivity@ this)) 2、使用TextWatcher 限制字数使用TextWather监听EditText的字符变化，我们需要实现三个抽象方法： beforeTextChanged(CharSequence s, int start, int count, int after)s: 修改之前的文字。start: 字符串中即将发生修改的位置。count: 字符串中即将被修改的文字的长度。如果是新增的话则为0。after: 被修改的文字修改之后的长度。如果是删除的话则为0。 onTextChanged(CharSequence s, int start, int before, int count)s: 改变后的字符串start: 有变动的字符串的序号before: 被改变的字符串长度，如果是新增则为0count: 添加的字符串长度，如果是删除则为0。 afterTextChanged(Editable s)s: 修改后的文字 上面的注释已经写得很明白了，比如在beforeTextChanged回调中，我们可以知道插入字符的位置start，还有插入的个数after，被替换的个数count，这与InputFilter中的各个参数含义相近。实现这几个函数：1234567891011121314151617181920212223242526272829303132333435class TextLengthWatcher(private val maxLength: Int = Utils.MAX_LENGTH, val listener: TextLengthListener? = null) : TextWatcher &#123; private var destCount: Int = 0 private var dStart: Int = 0 private var dEnd: Int = 0 override fun afterTextChanged(s: Editable) &#123; // count是输入后的字符长度 val count = Utils.calcTextLength(s) if (count &gt; maxLength) &#123; // 超过了sum个字符，需要截取 var sum = count - maxLength val delete = Utils.getDeleteIndex(s, dStart, dEnd, sum) listener?.onTextLengthOutOfLimit() if (delete &lt; dEnd) &#123; // 输入字符超过了限制，截取 s.delete(delete, dEnd) &#125; &#125; &#125; override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) &#123; destCount = Utils.calcTextLength(s) // 获取输入字符的起始位置 dStart = start // 获取输入字符的个数 dEnd = start + after &#125; override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) &#123; &#125;&#125; 需要注意的是，在TextWatcher中修改文本(Editable.delete、EditText.setText等)要小心不要陷入死循环。即：文字改变-&gt;watcher接收到通知-&gt;setText-&gt;文字改变-&gt;watcher接受到通知-&gt;…。所以我们在修改文本前加了一个结束条件count &gt; maxLength。在代码中添加TextWatcher监听即可实现功能 ：1edit_textwatcher.addTextChangedListener(TextLengthWatcher(listener = MainActivity@ this)) 3、使用InputConnection 限制字数InputConnection 是输入法和应用内View（通常是EditText）交互的通道，输入法的文本输入和删改事件，包括key event事件都是通过InputConnection发送给EditText。示意图如下：InputConnection有几个关键方法，通过重写这几个方法，我们基本可以拦截软键盘的所有输入和点击事件：123456789101112//当输入法输入了字符，包括表情，字母、文字、数字和符号等内容，会回调该方法public boolean commitText(CharSequence text, int newCursorPosition) //当有按键输入时，该方法会被回调。比如点击退格键时，搜狗输入法应该就是通过调用该方法，//发送keyEvent的，但谷歌输入法却不会调用该方法，而是调用下面的deleteSurroundingText()方法。 public boolean sendKeyEvent(KeyEvent event); //当有文本删除操作时（剪切，点击退格键），会触发该方法 public boolean deleteSurroundingText(int beforeLength, int afterLength) //结束组合文本输入的时候，回调该方法public boolean finishComposingText()； 从中可以发现，我们可以利用commitText来拦截用户的输入。设置InputConnection的方法在EditText类里面，所以我们继承EditText自定义一个TextLengthEditText。完全重写InputConnection的成本是很高的，我们可以继承InputConnectionWrapper类 ：1234567891011121314151617181920inner class TextLengthInputConnecttion( val target: InputConnection, private val maxLength: Int = Utils.MAX_LENGTH, val listener: TextLengthListener? = null) : InputConnectionWrapper(target, false) &#123; override fun commitText(source: CharSequence, newCursorPosition: Int): Boolean &#123; val count = Utils.calcTextLength(source) val destCount = Utils.calcTextLength(text as CharSequence, selectionStart, selectionEnd) if (count + destCount &gt; maxLength) &#123; // 超过了sum个字符，需要截取 var sum = count + destCount - maxLength val delete = Utils.getDeleteIndex(source, 0, source.length, sum) listener?.onTextLengthOutOfLimit() // 输入字符超过了限制，截取 return super.commitText(if (delete &gt; 0) source.subSequence(0, delete) else "", newCursorPosition) &#125; return super.commitText(source, newCursorPosition) &#125;&#125; 我们把TextLengthInputConnecttion定义成inner class，这样才能够访问外部类的成员。最后还需要通过重写EditText的onCreateInputConnection方法来设置InputConnection :123override fun onCreateInputConnection(outAttrs: EditorInfo?): InputConnection &#123; return TextLengthInputConnecttion(super.onCreateInputConnection(outAttrs), listener = TextLengthEditText@ this) &#125; 直接把自定义的TextLengthEditText添加在layout xml文件中即可实现功能。 总结本文介绍了三种限制字符个数的方法，各个方法各有优缺点，毕竟我们也要考虑到以后的扩展，不能哪个方便用哪个，不然以后需求变更的话就要修改很多代码了。最后各方法的总结对比如下： \ 优点 缺点 InputFilter 可以检测文本输入、删除 不能检测按键输入 TextWatcher 可以检测文本输入、删除 不能检测按键输入，只能在输入变更后检测，导致回调方法可能被多次执行 InputConnection 可以检测文本输入、删除，可以拦截按键输入，比InputFilter、TextWatcher先执行 实现时必须自定义EditText，比较麻烦 代码已经上传 Github 地址，欢迎star。 参考 android 使用 InputConnection 监听并拦截软键盘的退格键 Android TextWatcher三个回调详解，监听EditText的输入]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JetPack 之 ViewModel]]></title>
    <url>%2F2018%2F11%2F04%2FJetPack-%E4%B9%8B-ViewModel%2F</url>
    <content type="text"><![CDATA[ViewModel仍然是Model的范畴，是数据对象的载体，但是多了与视图(View)生命周期的绑定关系。可以简单理解为带有生命周期的数据对象。可在Activity, Fragment中使用，保证其在生命周期内的唯一性和一致性，不受配置的更改（例如屏幕旋转）。 ViewModel生命周期下图可以看出，ViewModel的生命周期和Activity/ Fragment一样甚至更长，因为如果发生屏幕旋转，ViewModel并没有跟着销毁，直到最终的onDestroy。 ViewModel的使用使用Android的ViewModel，需要在gradle添加引用：1implementation 'android.arch.lifecycle:extensions:1.1.1' ViewModel的声明 千万不能持有Context的引用，否则会引起内存泄漏，如果实在需要Context，可以继承AndroidViewModel，通过getApplication()获取Application。123public class CustomModel extends ViewModel &#123; public CustomObj obj;//业务内需要使用的对象&#125; 在代码中使用ViewModel。123456public class MyActivity extends Activity &#123; public void myFunction() &#123; CustomModel customModel = ViewModelProviders.of(MyActivity.this).get(CustomModel.class); customModel.obj...//自己操作该对象 &#125;&#125; ViewModel的实现原理通过上面的实例我们可知 ： 多个ViewModel存储在ViewModelStore中，本质上是一个Map存储的键值对。key为ViewModel的名字或者get方法时自己设置的key。 先查找ViewModelStore中是否含有该实例，有则直接返回，没有则通过反射的方式得到实例，并加入ViewModelStore中。 ViewModelProviders.of(activity/fragment)，通过activity/fragment拿到Application，当然AndroidViewModel也是通过反射拿到初始实例的，和ViewModel不同的是它需要将application传过去。 ViewModelStore在android support包和androidx下存储ViewModel的方式完全不同，但是暴露给我们使用的方法却是不变的。 在android support包中的实现： ViewModel本质上属于Activity/ Fragment级别，通过FragmentManager/ChildFragmentManager插入一个没有View的HolderFragment，ViewModelStore即保存在HolderFragment中； 在onCreate时setRetainInstance(true), 保证屏幕旋转时fragment不被销毁； HolderFragment在onDestroy时回调ViewModelStore.clear，循环调用ViewModelStore.onCleared。 在androidx包中的实现： ViewModel仍然属于Activity/Fragment级别，只是ViewModelStore是分别存储在FragmentActivity和Fragment中； 在Activity销毁重建过程是通过onRetainNonConfigurationInstance() 、getLastNonConfigurationInstance()保存和还原的ViewModelStore对象的； 在Fragment中的ViewModelStore会在配置变化的时候缓存在FragmentManagerNonConfig对象（包括不被销毁的fragment集合，循环嵌套的子Fragment的FragmentManagerNonConfig集合以及所有Fragment的ViewModelStore集合），它们在FragmentActivity重建onCreate时还原每个Fragment的ViewModelStore对象，可以说ViewModelStore的存储介质是正常被销毁的，只是ViewModelStore数据被保存并在特定场景下还原回来，保存和还原都是由FragmentActivity主动触发的； 如果是由配置更改导致Activity/Fragment onDestroy则不清除ViewModelStore的数据，反之则清除。 总之，不管采用不销毁ViewModelStore的存储介质，还是采用保存再还原数据的方式，都能保证在当前作用域下数据的唯一性和完整性。 参考文章 ViewModel Overview 官方文档]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JetPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JetPack 之 LiveData]]></title>
    <url>%2F2018%2F10%2F29%2FJetPack-%E4%B9%8B-LiveData%2F</url>
    <content type="text"><![CDATA[LiveData是一个可以感知Activity、Fragment生命周期的数据容器。当LiveData所持有的数据发生改变时，它会通知相应的观察者进行数据更新。由于Activity、Fragment都已实现LifecycleOwner接口，所以持有LifecycleOwner引用的LiveData在LifecycleOwner的生命周期处于started或paused时可以作出相应更新，而在LifecycleOwner处于被销毁时停止更新。 LiveData 的优点 保证UI状态和数据的统一LiveData采用了观察者设计模式。当生命周期状态改变时，LiveData会通知Observer对象。每次应用程序数据更改时，都会通知观察者对象，从而更新UI。 减少内存泄漏LiveData能够感知到组件的生命周期，观察者绑定到生命周期对象，并在其相关生命周期被破坏后自行清理。 当Activity停止时不会引起崩溃这是因为组件处于非激活状态时，不会收到LiveData中数据变化的通知 不需要额外的手动处理来响应生命周期的变化这一点同样是因为LiveData能够感知组件的生命周期，所以就完全不需要在代码中告诉LiveData组件的生命周期状态。 组件和数据相关的内容能实时更新组件在前台的时候能够实时收到数据改变的通知，这是可以理解的。当组件从后台到前台来时，LiveData能够将最新的数据通知组件，这两点就保证了组件中和数据相关的内容能够实时更新。 资源共享通过继承LiveData类，然后将该类定义成单例模式，在该类封装监听一些系统属性变化，然后通知LiveData的观察者 实例使用Android的LiveData，需要在gradle添加引用：123compile "android.arch.lifecycle:runtime:1.1.1'"compile "android.arch.lifecycle:extensions:1.1.1'"annotationProcessor "android.arch.lifecycle:compiler:1.1.1'" LiveData的代码比较简单，我们根据代码来了解其工作原理。我定义一个NetWorkState类，这个类的功能是对网络状态的广播进行监听。在onActive方法中注册广播，在onInactive取消广播，收到广播通知之后执行setValue将实例的值修改为当前网络状态并通知观察者12345678910111213141516171819202122class NetWorkState(val context: Context) : LiveData&lt;Boolean&gt;() &#123; private val broadcastReceiver: BroadcastReceiver = object : BroadcastReceiver() &#123; override fun onReceive(p0: Context?, p1: Intent?) &#123; value = NetworkUtils.isConnected() &#125; &#125; override fun onInactive() &#123; super.onInactive() context.unregisterReceiver(broadcastReceiver) &#125; override fun onActive() &#123; super.onActive() val intentFilter = IntentFilter() intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION) context.registerReceiver(broadcastReceiver, intentFilter) &#125;&#125; LiveData包含4个重要的方法： onActive()：当LiveData被激活时调用 onInactive()：当LiveData被取消时调用 setValue(T)：更新LiveData所持有的数据并通知观察者，必须在主线程调用 postValue(T)：与setValue(T)一样，不过可以在子线程中调用 LiveData使用起来很简单，直接初始化好LiveData对象之后，调用observe方法将其绑定在当前Activity的LifecycleOwner上123456789101112131415class LiveDataActivity : AppCompatActivity() &#123; val state: NetWorkState by lazy &#123; NetWorkState(applicationContext) &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) DataBindingUtil.setContentView&lt;ActivityLivedataBinding&gt;(this, R.layout.activity_livedata) state.observe(this, Observer&lt;Boolean&gt; &#123; Toast.makeText(this, if (it) "网络连接成功" else "网络连接失败", Toast.LENGTH_LONG).show() &#125;) &#125;&#125; LiveData的实现原理我们可以通过observe()源码方法入手来了解一下LiveData生命周期绑定的流程 ：12345678910111213141516171819@MainThreadpublic void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer) &#123; if (owner.getLifecycle().getCurrentState() == DESTROYED) &#123; // 如果owner处在DESTROYED的环节，则直接忽略 return; &#125; LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;&amp; !existing.isAttachedTo(owner)) &#123; // 重复添加会报异常 throw new IllegalArgumentException("Cannot add the same observer" + " with different lifecycles"); &#125; if (existing != null) &#123; return; &#125; owner.getLifecycle().addObserver(wrapper);&#125; 如果owner的声明周期处在DESTROYED的环节，则直接退出。在其他生命周期环节下，LiveData根据owner和observer构造LifecycleBoundObserver对象wrapper，首先检查mObservers是否已经添加了这个observer，如果重复添加会报异常，否则将其添加到mObservers。随后通过owner.getLifecycle().addObserver(wrapper)将其与Lifecycle进行绑定。 owner.getLifecycle().addObserver(wrapper)实际上调用的是Activity/Fragment中的mLifecycleRegistry来添加观察者，最终会调用到LifecycleRegistry中的addObserver(@NonNull LifecycleObserver observer)。这样Activity/Fragment的生命周期变化回调到LifecycleBoundObserver。 1234567891011121314151617181920212223242526272829303132class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver &#123; @NonNull final LifecycleOwner mOwner; LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer) &#123; super(observer); mOwner = owner; &#125; @Override boolean shouldBeActive() &#123; return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED); &#125; @Override public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) &#123; if (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123; removeObserver(mObserver); return; &#125; activeStateChanged(shouldBeActive()); &#125; @Override boolean isAttachedTo(LifecycleOwner owner) &#123; return mOwner == owner; &#125; @Override void detachObserver() &#123; mOwner.getLifecycle().removeObserver(this); &#125; &#125; LifecycleBoundObserver继承自ObserverWrapper并实现了GenericLifecycleObserver接口。当Activity/Fragment的生命周期变化会回调LifecycleBoundObserver.onStateChanged。如果owner处于DESTROYED，那么就移除当前组件Lifecycle绑定关系。反之则调用activeStateChanged(boolean newActive)。之前我们实现的onActive()与onInactive()全凭它控制。12345678910111213141516171819void activeStateChanged(boolean newActive) &#123; if (newActive == mActive) &#123; return; &#125; // immediately set active state, so we'd never dispatch anything to inactive // owner mActive = newActive; boolean wasInactive = LiveData.this.mActiveCount == 0; LiveData.this.mActiveCount += mActive ? 1 : -1; if (wasInactive &amp;&amp; mActive) &#123; onActive(); &#125; if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) &#123; onInactive(); &#125; if (mActive) &#123; dispatchingValue(this); &#125;&#125; 进入activeStateChanged()，首先判断当前的状态是否和上一次一致，一致则方法不执行。其次计算当前mActiveCount的数量，如果LiveData从未被激活过，则调用onActive()方法。因为多个activity有可能共享同一个LiveData，所以这里加入了mActiveCount计数。只要没有一个LiveData被激活，则回调onInactive()。当LiveData被重新激活后，就会执行dispatchingValue()来检查并处理之前没有发出去的通知，然后执行considerNotify()调用观察者的onChanged()将数据发送出去。1234567891011121314151617181920private void considerNotify(ObserverWrapper observer) &#123; if (!observer.mActive) &#123; return; &#125; // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) &#123; observer.activeStateChanged(false); return; &#125; if (observer.mLastVersion &gt;= mVersion) &#123; return; &#125; observer.mLastVersion = mVersion; //noinspection unchecked observer.mObserver.onChanged((T) mData); &#125; 首先要满足mActive为true，这个值改变渠道有2个地方： LiveData中组件绑定Lifecycle的时候，此时会将该值通过activeStateChanged()设置为true，解绑的时候设置为false； 在owner的生命周期发生改变的情况下，生命周期至少在onStart和onPause之间的时候设置为true，其他情况下为false。这就意味着只有在onStart和onPause之间发出的通知才可以立即收到。那onPause之后且未发生onDestory这段时期的通知=会被存在mData，但是也只能存最后一条通知。 从源码中可以看到，发送数据前还会检查数据版本号，由于每次执行setValue()或者postValue的时候，mVersion都会自增1，所以当你发出多个通知的时候，只有最后一条才会满足observer.mLastVersion &gt;= mVersion，因此也不用担心多条通知并发而产生的时序性问题。 MutableLiveDataLiveData中的setValue()与postValue是封装在其内部使用的，MutableLiveData只是将它拿出来，方便我们在外界使用，源码如下：1234567891011public class MutableLiveData&lt;T&gt; extends LiveData&lt;T&gt; &#123; @Override public void postValue(T value) &#123; super.postValue(value); &#125; @Override public void setValue(T value) &#123; super.setValue(value); &#125;&#125; MediatorLiveDataMediatorLiveData继承于MutableLiveData，可以同时监听多个LiveData，它提供了addSource()与removeSource()添加和删除LiveData。1234567891011121314151617181920212223@MainThreadpublic &lt;S&gt; void addSource(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;S&gt; onChanged) &#123; Source&lt;S&gt; e = new Source&lt;&gt;(source, onChanged); Source&lt;?&gt; existing = mSources.putIfAbsent(source, e); if (existing != null &amp;&amp; existing.mObserver != onChanged) &#123; throw new IllegalArgumentException( "This source was already added with the different observer"); &#125; if (existing != null) &#123; return; &#125; if (hasActiveObservers()) &#123; e.plug(); &#125;&#125;@MainThreadpublic &lt;S&gt; void removeSource(@NonNull LiveData&lt;S&gt; toRemote) &#123; Source&lt;?&gt; source = mSources.remove(toRemote); if (source != null) &#123; source.unplug(); &#125;&#125; MediatorLiveData比较特别的地方在于可以给它随时增加或删除一个LiveData，你可以让其中任何一个LiveData发送通知给MediatorLiveData。 参考文章 LiveData Overview 官方文档 Android架构组件四 Android Architecture Components LiveData组件解析]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JetPack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin中inline, noinline, crossinline的区别]]></title>
    <url>%2F2018%2F10%2F15%2FKotlin%E4%B8%ADinline-noinline-crossinline%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[我们在Kotlin中使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。 即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。 调用一个方法是一个压栈和出栈的过程，调用方法时将栈针压入方法栈，然后执行方法体，方法结束时将栈针出栈，这个压栈和出栈的过程会耗费资源，这个过程中传递形参也会耗费资源。 12345678fun &lt;T&gt; lock(l: Lock, body: () -&gt; T): T &#123; l.lock() try &#123; return body() &#125; finally &#123; l.unlock() &#125; &#125; 这个lock方法的方法体中，不会将它的形参再传递给其他方法。我们调用一下lock方法： 1lock(l, &#123;"do something!"&#125;)//l是一个Lock对象 对于编译器来说，调用lock方法就要将参数l和lambda表达式{“do something!”}进行传递，还要将lock方法进行压栈出栈处理，这个过程就会耗费资源。如果我们把lock方法删除，直接执行lock方法的方法体： 123456l.lock()try &#123; return "do something!"&#125; finally &#123; l.unlock()&#125; 这样做的效果和调用lock方法是一样的，而且不需要压栈出栈了，但是如果代码中频繁调用lock方法，必然要复制粘贴大量重复代码，还不如抽取出来一个lock方法，但是如果lock方法被频繁调用，压栈出栈将会带来性能问题。 那有什么方法，让程序避免写冗余代码，又能够提高效率呢？针对这个问题，kotlin引入了inline关键字。 inline在许多情况下通过内联化 lambda 表达式可以消除压栈出栈的开销。 下述函数是这种情况的很好的例子。即 lock() 函数可以很容易地在调用处内联。 考虑下面的情况： 1lock(l) &#123; foo() &#125; 编译器没有为参数创建一个函数对象并生成一个调用。取而代之，编译器可以生成以下代码： 123456l.lock()try &#123; foo() &#125; finally &#123; l.unlock()&#125; 这个不是我们从一开始就想要的吗？为了让编译器这么做，我们需要使用 inline 修饰符标记 lock() 函数： 1inline fun &lt;T&gt; lock(l: Lock, body: () -&gt; T): T &#123; …… &#125; inline 修饰符影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处。但是内联可能导致生成的代码增加，不过如果我们使用得当（即避免内联过大函数），性能上会有所提升。 另外inline也有个缺点，我们可以在 lambda 表达式 中调用return返回，可能会导致inline之后的代码无法执行 ，比如下面的代码 ：123456789101112131415inline fun higherOrderFunction(aLambda: () -&gt; Unit) &#123; aLambda() println("after invoke lambda") // 1&#125;fun callingFunction() &#123; higherOrderFunction &#123; println("invoke lambda...") // 2 return &#125; println("after callingFunction...") // 3&#125;// 打印结果 // "invoke lambda..." 当我们调用 callingFunction() ，只会打印”invoke lambda…”，说明 #1 、#3 的代码被跳过了，所以在使用inline函数中包含lambda静态式的时候，要避免在lambda中使用return ，应该使用return@higherOrderFunction的方式:1234567891011121314151617inline fun higherOrderFunction(aLambda: () -&gt; Unit) &#123; aLambda() println("after invoke lambda")&#125;fun callingFunction() &#123; higherOrderFunction &#123; println("invoke lambda...") return@higherOrderFunction &#125; println("after callingFunction...")&#125;// 打印结果 // invoke lambda...// after invoke lambda// after callingFunction... 使用return@higherOrderFunction的方式返回得到的结果正确。不过kotlin也有另一种方式来限制在lambda中直接return，那就是使用 noinline 或 crossinline 。 noinline如果你只想被（作为参数）传给一个内联函数的 lamda 表达式中只有一些被内联，你可以用 noinline 修饰符标记某些lambda表达式禁止内联： 1inline fun foo(inlined: () -&gt; Unit, noinline notInlined: () -&gt; Unit) &#123; …… &#125; 可以内联的 lambda 表达式只能在内联函数内部调用或者作为可内联的参数传递， 但是 noinline 的可以以任何我们喜欢的方式操作：存储在字段中、传送它等等。 另外，定义了noinline 的lambda表达式将不能直接调用 return ，否则会报错 ：123456789101112inline fun higherOrderFunction(noinline aLambda: () -&gt; Unit) &#123; aLambda() println("after invoke lambda")&#125;fun callingFunction() &#123; higherOrderFunction &#123; println("invoke lambda...") return // 编译不通过，`noinline` 的lambda表达式不能直接 return &#125; println("after callingFunction...")&#125; 需要注意的是，如果一个内联函数没有可内联的函数参数并且没有具体化的类型参数，编译器会产生一个警告，因为内联这样的函数很可能并无益处（如果你确认需要内联，则可以用 @Suppress(&quot;NOTHING_TO_INLINE&quot;) 注解关掉该警告）。 crossinline使用crossinline也可以限制lambda表达式将不能直接调用 return ，它与 noinline 的区别在于使用crossinline的lambda仍然是inline的，比如下面使用noinline 的代码：12345678910111213141516inline fun higherOrderFunction(aLambda1: () -&gt; Unit, noinline aLambda2: () -&gt; Unit) &#123; aLambda1() aLambda2() println("after invoke lambda")&#125;fun callingFunction() &#123; higherOrderFunction(&#123; println("invoke lambda1...") return@higherOrderFunction &#125;, &#123; println("invoke lambda2...") return@higherOrderFunction &#125;) println("after callingFunction...")&#125; 其中aLambda1是inline的，而aLambda2是noinline的，查看编译后的代码：12345678910111213141516171819public static final void higherOrderFunction(@NotNull Function0 aLambda1, @NotNull Function0 aLambda2) &#123; Intrinsics.checkParameterIsNotNull(aLambda1, "aLambda1"); Intrinsics.checkParameterIsNotNull(aLambda2, "aLambda2"); aLambda1.invoke(); aLambda2.invoke(); String var3 = "after invoke lambda"; System.out.println(var3); &#125; public static final void callingFunction() &#123; Function0 aLambda2$iv = (Function0)null.INSTANCE; String var1 = "invoke lambda1..."; System.out.println(var1); aLambda2$iv.invoke(); var1 = "after invoke lambda"; System.out.println(var1); String var4 = "after callingFunction..."; System.out.println(var4); &#125; 从上面的代码我们可以发现aLambda1被内联到调用函数callingFunction中，而aLambda2并没有被内联到调用函数callingFunction中。如果我们把noinline修改成crossinline，如下所示： 12345678910111213141516inline fun higherOrderFunction(aLambda1: () -&gt; Unit, crossinline aLambda2: () -&gt; Unit) &#123; aLambda1() aLambda2() println("after invoke lambda")&#125;fun callingFunction() &#123; higherOrderFunction(&#123; println("invoke lambda1...") return@higherOrderFunction &#125;, &#123; println("invoke lambda2...") return@higherOrderFunction &#125;) println("after callingFunction...")&#125; 同样aLambda1是inline的，而aLambda2是crossinline的，查看编译后的代码：12345678910111213141516171819public static final void higherOrderFunction(@NotNull Function0 aLambda1, @NotNull Function0 aLambda2) &#123; Intrinsics.checkParameterIsNotNull(aLambda1, "aLambda1"); Intrinsics.checkParameterIsNotNull(aLambda2, "aLambda2"); aLambda1.invoke(); aLambda2.invoke(); String var3 = "after invoke lambda"; System.out.println(var3); &#125; public static final void callingFunction() &#123; String var0 = "invoke lambda1..."; System.out.println(var0); var0 = "invoke lambda2..."; System.out.println(var0); var0 = "after invoke lambda"; System.out.println(var0); var0 = "after callingFunction..."; System.out.println(var0); &#125; 从上面的代码我们可以发现aLambda1和 aLambda2都被内联到调用函数callingFunction中了。 总结本文主要介绍inline, noinline, crossinline的区别。为了减少使用高阶函数带来的一些运行时的效率损失，可以使用inline来标记一个函数为内联函数，内联函数在编译后会把代码都插入到调用函数的地方，所以可能导致最终的代码增加，所以必须避免内联过大函数才能使内联函数性能提升。另外我们可以用noinline和crossinline来限制内联函数中的lambda直接调用return返回，避免出现预料之外的结果。 参考 inline, noinline, crossinline — What do they mean?]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Unicode编码格式和代码中的应用]]></title>
    <url>%2F2018%2F09%2F18%2F%E6%B5%85%E8%B0%88Unicode%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%92%8C%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ASCII码ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套计算机编码系统。它主要用于显示现代英语，一共定义了 128 个字符，其中33个字符无法显示（一些终端提供了扩展，使得这些字符可显示为诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。例如大写的字母 A 是 65（这是十进制数，对应二进制是0100 0001）。 ASCII的局限在于只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语（而且在处理英语当中，即使会违反拼写规则，外来词如naïve、café、élite等等时，所有重音符号都必须去掉）。虽然EASCII解决了部分西欧语言的显示问题，但对更多其他语言依然无能为力。因此，现在的软件系统大多采用Unicode。 Unicode码Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得计算机可以用更为简单的方式来呈现和处理文字。 Unicode早期版本中，CJK统一汉字区的范围是0x4E00-0x9FA5，包含20902个汉字。后来增加了22个字符，码位是0x9FA6-0x9FBB。所以我们在百度判断中文的代码一般都是判断在 0x4E00-0x9FA5 的范围内，这是不完全正确的，因为在最新的Unicode 5.0的99089个字符中，有71226个字符与汉字有关，包括了很多兼容汉字和扩充汉字，对于多语言版本的APP可能要注意这些。 Unicode 没有规定字符对应的二进制码如何存储。比如汉字“中”，它的 Unicode 码点是 0x4E2D，对应的二进制数是 100111000101101，二进制数有 15 位，这也就说明了它至少需要 2 个字节来表示。还有字母“A”，Unicode 码点是 0x0041，对应的二进制数是 0100 0001，二进制数有8位，用1个字节就可以表示了。 那么计算机是如何知道1个字节表示一个字符还是2个字节表示一个字符呢？也许有人会觉得可以用Unicode 中最大的字符用 4 字节来表示每一个字符，但是这样肯定会造成了空间的极大浪费，如果是一个英文文档，那文件大小就大出了 3 倍多了。为了解决 Unicode 的编码问题， UTF-8 和 UTF-16 两种当前比较流行的编码方式诞生了。 UTF-8UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，它的最大特点就是可变长。它可以使用 1 - 4 个字节表示一个字符，根据字符的不同变换长度。编码规则如下： 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码点。因此，对于英文中的 0 - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码那个年代的文档用 UTF-8 编码打开完全没有问题。 对于需要使用 N 个字节来表示的字符（N &gt; 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设位 10，剩下的二进制位则使用这个字符的 Unicode 码点来填充。 点的位数 | 码点起值 | 码点终值 | 字节序列 | Byte 1 | Byte 2 | Byte 3 | Byte 4 | Byte 5 | Byte 6–|–|–|–|–|–|–|–|–|–7 | U+0000 | U+007F | 1 | 0xxxxxxx 1 | U+0080 |U+07FF | 2 | 110xxxxx | 10xxxxxx 6 | U+0800 |U+FFFF | 3 | 1110xxxx |10xxxxxx | 10xxxxxx | 1 | U+10000 |U+1FFFFF | 4 | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx 6 | U+200000 |U+3FFFFFF | 5 | 111110xx | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx 1 | U+4000000 |U+7FFFFFFF | 6 | 1111110x | 10xxxxxx | 10xxxxxx |10xxxxxx | 10xxxxxx | 10xxxxxx 根据上面编码规则对照表，就很容易进行 UTF-8 编码和解码。以汉字“中”为例，“中”的 Unicode 码点是 0x4E2D（100 1110 0010 1101），通过上面的对照表可以发现，0x0000 4E2D 位于第三行的范围，那么得出其格式为 1110xxxx 10xxxxxx 10xxxxxx。接着，从“中”的二进制数最后一位开始，从后向前依次填充对应格式中的 x，多出的 x 用 0 补上。这样，就得到了“汉”的 UTF-8 编码为 11100100 10111000 10101101，转换成十六进制就是 0xE4 0xB8 0xAD。 解码的过程也十分简单：如果一个字节的第一位是 0 ，则说明这个字节对应一个字符；如果一个字节的第一位1，那么连续有多少个 1，就表示该字符占用多少个字节，知道了该字符占用N个字节就可以篇历后面以10开头的N个字符，最终解析出该字符。 UTF-16Unicode的编码空间从U+0000到U+10FFFF，共有 2^17 个码位可用来映射字符. Unicode的编码空间可以划分为17个平面（plane），每个平面包含2^16（65,536）个码位。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0x00到0x10，共计17个平面。第一个平面称为基本多语言平面（Basic Multilingual Plane, BMP），或称第零平面（Plane 0）。其他平面称为辅助平面（Supplementary Planes）。 基本平面（BMP）的字符位共有 2^16 个，从U+0000到U+FFFF，包含了最常用的字符。其中从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 辅助平面（Supplementary Planes）的字符位共有 2^20 个，从U+10000到U+10FFFF，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 U+D800 到 U+DBFF，称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF，称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 因此，当我们遇到两个字节，发现它的码位在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码位，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 以汉字”𠮷”为例，汉字”𠮷”的 Unicode 码点为 0x20BB7，该码点显然超出了基本平面的范围（0x0000 - 0xFFFF），因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 = 0x10BB7 计算出超出的部分，然后将其用 20 个二进制位表示（不足前面补 0 ），结果为0001000010 1110110111。接着，将前 10 位映射到 U+D800 到 U+DBFF 之间，后 10 位映射到 U+DC00 到 U+DFFF 即可。前10位是0001000010，对应十六进制是0x42，映射到U+D800后就是 0xD842，同理后10位是1110110111，对应十六进制是0x03B7，映射到U+DC00 后就是 0xDFB7。因此得出汉字”𠮷”的 UTF-16 编码为 0xD842 0xDFB7。 代码中处理Unicode码java默认是使用UTF-16编码处理字符的，很多字符处理的函数都定义在Character类中，以上文中的汉字“中”、“𠮷”为例，获取字符的码位 ：123456val str = "中" // str.length = 1val str2 = "𠮷" // str2.length = 2// 获取码位 ：println(Character.codePointAt(str, 0).toString(16)) // 4E2Dprintln(Character.codePointAt(str2, 0).toString(16)) // 20BB7 打印结果与预想的一致，我们也可以用Character. charCount来判断一个码位占用的字符数，通过上方分析可知汉字”𠮷”占用四个字节，这里要注意函数名是charCount，说明计算的是char的数量，一个char占两个字节，所以”𠮷”的 Character.charCount 打印的是2，而 “中”的 Character.charCount 打印的是1。123// 判断字符字符数println(Character.charCount(Character.codePointAt("中", 0))) // 1println(Character.charCount(Character.codePointAt("𠮷", 0))) // 2 那么Character这个类又是怎样知道一个字符占两个字节还是四个字节呢？我们看看Character.charCount 函数的源码 ：12345// Character.javapublic static final int MIN_SUPPLEMENTARY_CODE_POINT = 0x010000;public static int charCount(int codePoint) &#123; return codePoint &gt;= MIN_SUPPLEMENTARY_CODE_POINT ? 2 : 1; &#125; 从中可以发现 ，当码位大于等于0x010000时就是2个char（四个字节），否则是1个char（两个字节）,而通过上文分析我们知道码位大于等于0x010000就是在辅助平面，这时候是由一个高位和一个低位组合的，在辅助平面上的字符至少占用四个字节，我们可以打印汉字”𠮷”的每一个char ：123456789101112131415"中".map &#123; String.format("%x ", it.toInt()).toUpperCase()&#125;.reduce &#123; acc, s -&gt; acc + s&#125;.run &#123; println(this) // 4E2D&#125;"𠮷".map &#123; String.format("%x ", it.toInt()).toUpperCase()&#125;.reduce &#123; acc, s -&gt; acc + s&#125;.run &#123; println(this) // D842 DFB7&#125; 通过打印结果，可知汉字”中”的UTF-16就是0x4E2D，汉字”𠮷”的UTF-16就是0xD842 0xDFB7。另外，Character也提供了两个函数来判断一个字符是高位还是低位，因为“中”由两个字节组成，不需要高位低位，所以Character.isHighSurrogate、Character.isLowSurrogate均打印false。 ：12345678910111213 // 判断高位、低位 ： "中".forEachIndexed &#123; index, c -&gt; println("中[$index] isHighSurrogate = $&#123;Character.isHighSurrogate(c)&#125; , isLowSurrogate = $&#123;Character.isLowSurrogate(c)&#125;") &#125; "𠮷".forEachIndexed &#123; index, c -&gt; println("𠮷[$index] isHighSurrogate = $&#123;Character.isHighSurrogate(c)&#125; , isLowSurrogate = $&#123;Character.isLowSurrogate(c)&#125;") &#125;// 打印结果 ： // 中[0] isHighSurrogate = false , isLowSurrogate = false// 𠮷[0] isHighSurrogate = true , isLowSurrogate = false// 𠮷[1] isHighSurrogate = false , isLowSurrogate = true 另外如果我们要把UTF-16编码转化成UTF-8编码，可以这样做 ：12345678910111213141516// UTF-16转化成UTF-8编码 ："中".toByteArray().map &#123; String.format("%x ", it).toUpperCase()&#125;.reduce &#123; acc, s -&gt; acc + s&#125;.run &#123; println(this) // E4 B8 AD&#125;"𠮷".toByteArray().map &#123; String.format("%x ", it).toUpperCase()&#125;.reduce &#123; acc, s -&gt; acc + s&#125;.run &#123; println(this) // F0 A0 AE B7 &#125; 通过打印结果，可知汉字”𠮷”的UTF-8就是0xE4 0xB8 0xAD，汉字”𠮷”的UTF-8就是0xF0 0xA0 0xAE 0xB7 。同理把UTF-8编码也可以转化成UTF-16编码，如下所示：123456// UTF-8转化成UTF-16编码 ：val bytes1 = byteArrayOf(0xE4.toByte(), 0xB8.toByte(), 0xAD.toByte())println(String(bytes1, Charset.forName("utf-8"))) // "中"val bytes2 = byteArrayOf(0xF0.toByte(), 0xA0.toByte(), 0xAE.toByte(), 0xB7.toByte())println(String(bytes2, Charset.forName("utf-8"))) // "𠮷" 我们可以直接用\u的前缀来显示一个UTF-16编码，从而直接打印我们所要的字符，比如汉字”中”的UTF-16就是0x4E2D，汉字”𠮷”的UTF-16就是0xD842 0xDFB7，我们可以直接用\u4E2D来打印“中”，用\uD842\uDFB7来打印“𠮷”，代码如下：12println("\u4E2D") // "中"println("\uD842\uDFB7") // "𠮷" 总结本文介绍了ASCII码，但是ASCII只能最多表示128个字符，所以有了Unicode编码，Unicode编码有多种编码格式，比较流行的有UTF-8和UTF-16。UTF-8使用 1 - 4 个字节表示一个字符，而UTF-16则通过高位、低位的形式来表示Unicode所有平面的字符，UTF-16最多占4个字节。最后介绍了在代码中处理unicode编码的主要函数，实际工作中很实用。 参考 彻底弄懂 Unicode 编码]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[译]Kotlin的Reified实化类型参数]]></title>
    <url>%2F2018%2F08%2F23%2F%E8%AF%91-Kotlin%E7%9A%84Reified%E5%AE%9E%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[让我们来想一想在Kotlin中你可以用类名来做些什么，想想你在源码中编写类名的所有场景。我想到了以下15种情景。 1、定义一个成员属性 1private val thing: Thing 2、函数参数 1fun doSomething(thing: Thing) &#123;&#125; 3、类型实参 1val list = listOf&lt;Thing&gt;() 4、类型形参约束 1class Item&lt;T : Thing&gt; 5、强制类型转换 1something as Thing 6、定义一个类 1open class Thing &#123;&#125; 7、继承一个类 1class Other : Thing() 8、导入一个类 1import com.example.Thing 9、给类名定义typealias别名 1typealias Thingy = Thing 10、构建一个对象 1val thing = Thing() 11、捕获一个错误类型 1catch (e: ExceptionalThing) 12、调用静态方法 1Thing.doStaticStuff() 13、定义函数引用 1val function = Thing::doSomething 14、类型比较 1something is Thing 15、获得类的一个Class对象： 1val clazz = Thing::class.java 问题来了现在，最大的问题是： 在上面哪些案例中我们应该使用泛型类型参数引用而不是真实的类名？ 换句话说，上面15种案例中哪些我们可以用类型参数比如 T去替代Thing类呢? 你在哪些地方可以引用类型参数？你想到了什么？ 这是我能想到的 - 上面的案例1-5都可以采用类型参数。让我们一起展示所有五个： 1234567891011121314class GenericThing&lt;T&gt;(constructorArg: T) &#123; // 1. Define a member property 定义一个成员属性 private val thing: T = constructorArg // 2. Define the type of a function argument 定义函数参数 fun doSomething(thing: T) = println(thing) // 3. Use as a type argument 定义泛型类型实参 fun emptyList() = listOf&lt;T&gt;() // 4. Use as a type parameter constraint, and... 使用作为类型形参约束 // 5. Cast to the type (produces "unchecked cast" warning) 强制类型转换 fun &lt;U : T&gt; castIt(): T = thing as U&#125; 你在哪些地方可以不引用类型参数？引用类型参数适用于案例1-5。但是对于案例6-15，如果我们要在（例如，Thing或ExceptionalThing）的地方替换类型参数（例如T），则最终会出现编译器错误。 在某些情况下，使用类型参数是没有意义的。例如，在案例6中我们正在定义一个类 - 根据其类型参数之一定义一个类有什么意义呢？ 在其他情况下，Java和Kotlin通过反射提供一些变通的方法，例如构建对象(案例10) 但在某些情况下，能够使用类型参数肯定会很好。特别是，案例14和15–比较类型和分配类对象 - 在某些情况下会非常方便。 Reified类型实化参数介绍Java限制了哪些类型是reifiable - reifiable也就意味着它们“在运行时完全可用”(具体可查阅:Java SE specs on reifiable types)，泛型类型参数通常在编译期间被擦除，但是在Kotlin中的reified类型参数的情况下, 由于底层语法下一些巧妙的技巧，让运行时也能准确拿到泛型参数类型信息。 Reified类型参数仅适用于函数（或具有get（）函数的扩展属性），并且仅适用于声明为inline内联的函数。这是一个例子： 1inline fun &lt;reified T&gt; Any.isInstanceOf(): Boolean = this is T 当您将函数标记为inline时，编译器会把实现内联函数的字节码插入到每次调用发生的地方。这就是reified类型的工作原理 - 具体实际类型在调用地方是已经知道的，因此在调用x.isInstanceOf&lt;String&gt;()有效地把x编译为String. reified类型实化参数经常被使用到的几个地方上面的案例15是许多Kotlin开发人员最喜欢的案例。假设我们有一个User类，以及我们想要读取的JSON字符串 123456data class User(val first: String, val last: String)val json = """&#123; "first": "Sherlock", "last": "Holmes" &#125;"" 在Java序列化库（如Gson）中，当您想要反序列化该JSON字符串时，您最终必须将Class对象作为参数传递，以便Gson知道您想要的类型。 1User user = new Gson().fromJson(getJson(), User.class); 现在，让我们一起展示reified类型实化参数的魔法 我们将创建一个非常轻量级的扩展函数来包装Gson方法： 12inline fun &lt;reified T&gt; Gson.fromJson(json: String) = fromJson(json, T::class.java) 现在，在我们的Kotlin代码中，我们可以反序列化JSON字符串，甚至根本不需要传递类型信息！ 1val user: User = Gson().fromJson(json) Kotlin根据它的用法推断出类型 - 因为我们将它分配给User类型的变量，Kotlin使用它作为fromJson（）的类型参数。或者，您可以使类型推断其他的类： 1val user = Gson().fromJson&lt;User&gt;(json) 在这种情况下，从传递给fromJson（）的类型参数推断出user类型。 参考 Getting Real with Kotlin’s Reified Type Parameters]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin中 run, with, let, also and apply 函数的分类与对比]]></title>
    <url>%2F2018%2F05%2F30%2FKotlin%E4%B8%AD-run-with-let-also-and-apply-%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[Kotlin提供了run, with, let, also and apply等功能函数，使用这些功能函数可以提高代码的可读性和简洁性。比如如下的代码利用java实现是这样的 ：1234567891011121314151617public static int getPeopleTotalAge(People people) &#123; if (people == null) &#123; return 0; &#125; int age = people.age; if (people.child1 != null) &#123; age += people.child1.age; &#125; if (people.child2 != null) &#123; age += people.child2.age; &#125; return age; &#125; 如果用Kotlin来实现，就能变得很简洁：123fun getPeopleTotalAge(people: JavaTest.People?) = people?.run &#123; (child1?.age ?: 0) + (child2?.age ?: 0) + age&#125; ?: 0 Kotlin中 run, with, let, also and apply在使用上有很多区别，我把这几个函数又能分成如下三类。 三种类型1.普通函数与扩展函数with 和 T.run 很类似，比如下面的代码中，实现的功能一样 ：123456789with(people.settings) &#123; javaScriptEnabled = true databaseEnabled = true &#125; people.settings.run &#123; javaScriptEnabled = true databaseEnabled = true &#125; 但是区别在于 with 是一个普通函数，但是T.run 是一个扩展函数，那么用哪个比较好呢？ 假设 people.settings 可能为null，那上面的代码应该修改为如下 ：1234567891011// 比较繁杂 with(people.settings) &#123; this?.javaScriptEnabled = true this?.databaseEnabled = true &#125; // 比较简洁 people.settings?.run &#123; javaScriptEnabled = true databaseEnabled = true &#125; 所以根据具体使用场景选择with 和 T.run，可以使代码更简洁。另外要注意一下，run 函数也有普通函数的版本，与T.run 使用上没有什么区别，比如下面的代码 ：123456fun testRun(i: Int) = run &#123; if (i &lt; 0) &#123; return 0 &#125; i + 1&#125; 2.this参数与it参数T.run 与 T.let 也很类似，比如下面的代码中，实现的功能一样 ：1234567stringVariable?.run &#123; println("The length of this String is $length")&#125;stringVariable?.let &#123; println("The length of this String is $&#123;it.length&#125;")&#125; 从代码中明显区别是T.run 可以直接调用属性，而T.let需要通过it来调用属性，如果我们查看这两个函数的源码 ：12345678910111213public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block(this)&#125;public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return block()&#125; 可以发现，T.run 是通过扩展的方式来传递参数 block: T.() -&gt; R；但是T.let 是传递一个函数 block: (T) -&gt; R。所以T.run可以直接调用，但是T.let需要it调用。虽然T.run 看起来比T.let 更好用，但是在一些情况下更适合用T.let : T.let 明确了参数的关系，在调用参数时不会和其它全局变量搞混； T.let 中的it 也可以换名字，提高代码的可读性；1234stringVariable?.let &#123; nonNullString -&gt; println("The non null string is $nonNullString")&#125; 另外，T.apply 与 T.also 也一样，前者可以直接调用参数，后者需要通过it来调用参数。比如下面的代码 ：1234567stringVariable?.apply &#123; println("The length of this String is $length")&#125;stringVariable?.also &#123; println("The length of this String is $&#123;it.length&#125;")&#125; 3.返回this或返回最后一行T.let 和 T.also 使用上是差不多的，通过前面的分析我们知道都是通过it来调用参数。但是在下面的例子中，它们还是有些许不同：12345678910111213141516171819202122232425262728293031val original = "abc"original.let &#123; println("The original String is $it") // "abc" it.reversed()&#125;.let &#123; println("The reverse String is $it") // "cba" it.length&#125;.let &#123; println("The length of the String is $it") // 3&#125;//错误，一直返回"abc"original.also &#123; println("The original String is $it") // "abc" it.reversed() &#125;.also &#123; println("The reverse String is $&#123;it&#125;") // "abc" it.length&#125;.also &#123; println("The length of the String is $&#123;it&#125;") // "abc"&#125;//正确，结果与调用T.let一致original.also &#123; println("The original String is $it") // "abc"&#125;.also &#123; println("The reverse String is $&#123;it.reversed()&#125;") // "cba"&#125;.also &#123; println("The length of the String is $&#123;it.length&#125;") // 3&#125; T.also 返回的是this，即”abc”，所以像T.let链式调用的时候，一直返回”abc”，导致代码逻辑错误。T.also比较适合运用于链式调用，比如AlertDialog.Builder创建对话框时的调用方式。混合运用T.let和T.also能使代码更加简洁，比如下面的代码 ：123456789// 一般实现方式fun makeDir(path: String): File &#123; val result = File(path) result.mkdirs() return result&#125;// 改进后的方式fun makeDir(path: String) = path.let&#123; File(it) &#125;.also&#123; it.mkdirs() &#125; 同理，T.apply 和 T.run 也是这种类型的组合，T.apply 返回this，而T.run 返回的是最后一行。 总结通过前面的分类对比，我们知道这些函数可以分成三类： 普通函数与扩展函数 （with 与 T.run） this参数与it参数（T.run 与 T.let、T.apply 与 T.also） 返回this或返回最后一行（T.let 和 T.also、T.apply 与 T.run） 我们可以整理出一个表格，明确了各个函数的使用方式： \ 是否扩展函数 调用参数方式 返回值 with 是 this 最后一行 T.run 否 this 最后一行 T.let 否 it 最后一行 T.apply 否 this this T.also 否 it this]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SurfaceView, TextureView, SurfaceTexture等的区别]]></title>
    <url>%2F2018%2F03%2F24%2FSurfaceTexture%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1、SurfaceView1.1、概述SurfaceView继承自类View，因此它本质上是一个View。但与普通View不同的是，它有自己的Surface，在WMS中有对应的WindowState，在SurfaceFlinger中有Layer。 调用者可以通过lockCanvas获得了一块类型为Canvas的画布之后，就可以调用Canvas类所提供的绘图函数来绘制任意的UI了，例如，调用Canvas类的成员函数drawLine、drawRect和drawCircle可以分别用来画直线、矩形和圆。 调用者在画布上绘制完成所需要的UI之后，通过调用SurfaceHolder类的成员函数unlockCanvasAndPost就可以将这块画布的图形绘冲区的UI数据提交给SurfaceFlinger服务来处理了，以便SurfaceFlinger服务可以在合适的时候将该图形缓冲区合成到屏幕上去显示，这样就可以将对应的SurfaceView的UI展现出来了。 1.2、双缓冲机制SurfaceView在更新视图时用到了两张Canvas，一张frontCanvas和一张backCanvas，每次实际显示的是frontCanvas，backCanvas存储的是上一次更改前的视图，当使用lockCanvas（）获取画布时，得到的实际上是backCanvas而不是正在显示的frontCanvas，之后你在获取到的backCanvas上绘制新视图，再unlockCanvasAndPost（canvas）此视图，那么上传的这张canvas将替换原来的frontCanvas作为新的frontCanvas，原来的frontCanvas将切换到后台作为backCanvas。例如，如果你已经先后两次绘制了视图A和B，那么你再调用lockCanvas（）获取视图，获得的将是A而不是正在显示的B，之后你将重绘的C视图上传，那么C将取代B作为新的frontCanvas显示在SurfaceView上，原来的B则转换为backCanvas。 1.3、SurfaceView优点与缺点 优点： 使用双缓冲机制，可以在一个独立的线程中进行绘制，不会影响主线程，播放视频时画面更流畅 缺点：Surface不在View hierachy中，它的显示也不受View的属性控制，SurfaceView 不能嵌套使用。在7.0版本之前不能进行平移，缩放等变换，也不能放在其它ViewGroup中，在7.0版本之后可以进行平移，缩放等变换。 2、TextureView2.1、概述在4.0(API level 14)中引入，与SurfaceView一样继承View，它可以将内容流直接投影到View中，TextureView重载了draw()方法，其中主要SurfaceTexture中收到的图像数据作为纹理更新到对应的HardwareLayer中。 和SurfaceView不同，它不会在WMS中单独创建窗口，而是作为View hierachy中的一个普通View，因此可以和其它普通View一样进行移动，旋转，缩放，动画等变化。值得注意的是TextureView必须在硬件加速的窗口中。它显示的内容流数据可以来自App进程或是远端进程。 2.2、TextureView优点与缺点 优点：支持移动、旋转、缩放等动画，支持截图 缺点：必须在硬件加速的窗口中使用，占用内存比SurfaceView高，在5.0以前在主线程渲染，5.0以后有单独的渲染线程。 2.3、TextureView与SurfaceView对比 \ SurfaceView TextureView 内存 低 高 绘制 及时 1~3帧的延迟 耗电 低 高 动画与截图 不支持 支持 TextureView总是使用GL合成，而SurfaceView可以使用硬件overlay后端，可以占用更少的内存带宽，消耗更少的CPU（耗电）； TextureView的内部缓冲队列导致比SurfaceView使用更多的内存； 3、SurfaceTexture3.1、概述SurfaceTexture 类是在 Android 3.0 中引入的。当你创建了一个 SurfaceTexture，你就创建了你的应用作为消费者的 BufferQueue。当一个新的缓冲区由生产者入队列时，你的应用将通过回调 (onFrameAvailable()) 被通知。你的应用调用 updateTexImage()，这将释放之前持有的缓冲区，并从队列中获取新的缓冲区，执行一些 EGL 调用以使缓冲区可作为一个外部 texture 由 GLES 使用。 3.2、SurfaceTexture与SurfaceView对比SurfaceTexture和SurfaceView不同的是，它对图像流的处理并不直接显示，而是转为OpenGL外部纹理，因此可用于图像流数据的二次处理（如Camera滤镜，桌面特效等）。比如Camera的预览数据，变成纹理后可以交给GLSurfaceView直接显示，也可以通过SurfaceTexture交给TextureView作为View heirachy中的一个硬件加速层来显示。 4、GLSurfaceViewGLSurfaceView从Android 1.5(API level 3)开始加入。在SurfaceView的基础上，和SurfaceView不同的是，它加入了EGL的管理，并自带了渲染线程。另外它定义了用户需要实现的Render接口，只需要将实现了渲染函数的Renderer的实现类设置给GLSurfaceView即可。 GLSurfaceView也可以作为相机的预览，但是需要创建自己的SurfaceTexture并调用OpenGl API绘制出来。GLSurfaceView 本身自带EGL的管理，并有渲染线程，这对于一些需要多个EGLSurface的场景将不适用。 参考 Android视图SurfaceView的实现原理分析 视频画面帧的展示控件SurfaceView及TextureView对比 SurfaceTexture，TextureView, SurfaceView和GLSurfaceView的区别 SurfaceTexture]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Andriod设置clipChildren属性]]></title>
    <url>%2F2018%2F02%2F23%2FAndriod%E8%AE%BE%E7%BD%AEclipChildren%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Android中有一个不常用的属性android:clipChildren，该属性值可设为true或者false。该属性控制Android的一个子view是否运行超越父控件边界放置。Android系统默认赋予该属性值是true，即不允许超越所在父布局的边界。如果设置为false，则表示允许该子view超越父布局的边界。这个属性可以实现特别的动画效果，比如可以超载父布局区域的放大动画。 当把android:clipChildren的属性设置为false后，在Android的UI设计中会产生一些比较有趣的设计效果，比如下面一个在LinearLayout布局中简单水平并排放置的若干ImageView效果，如图： 上面效果实现的代码（布局XML）如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:clipChildren="false" android:orientation="vertical" &gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="100dip" android:background="#e57373" /&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="50dip" android:background="#2196f3" android:orientation="horizontal" &gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="match_parent" android:src="@drawable/ic_launcher" /&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="50dip" android:layout_gravity="bottom" android:src="@drawable/ic_launcher" /&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="70dip" android:layout_gravity="bottom" android:src="@drawable/ic_launcher" /&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="90dip" android:layout_gravity="bottom" android:src="@drawable/ic_launcher" /&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="110dip" android:layout_gravity="bottom" android:src="@drawable/ic_launcher" /&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="130dip" android:layout_gravity="bottom" android:src="@drawable/ic_launcher" /&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="150dip" android:layout_gravity="bottom" android:src="@drawable/ic_launcher" /&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="170dip" android:layout_gravity="bottom" android:src="@drawable/ic_launcher" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="100dip" android:background="#4dd0e1" /&gt;&lt;/LinearLayout&gt; 设置android:layout_gravity=&quot;bottom&quot;， 告知Android系统要从底部向上绘制该子view。每个ImageView高度不断增加，并且可以绘制在父布局区域之外，这种效果同样也适用于动画。]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程-ThreadPoolExecutor的拒绝策略RejectedExecutionHandler]]></title>
    <url>%2F2018%2F01%2F21%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadPoolExecutor%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5RejectedExecutionHandler%2F</url>
    <content type="text"><![CDATA[概述在分析Java多线程-线程池ThreadPoolExecutor时，ThreadPoolExecutor的构造函数有一个RejectedExecutionHandler参数。RejectedExecutionHandler是一个接口：123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable r, ThreadPoolExecutor executor);&#125; 里面只有一个方法。当要创建的线程数量大于线程池的最大线程数的时候，新的任务就会被拒绝，就会调用这个接口里的这个方法。可以自己实现这个接口，实现对这些超出数量的任务的处理。 ThreadPoolExecutor自己已经提供了四个拒绝策略，分别是 CallerRunsPolicy AbortPolicy DiscardPolicy DiscardOldestPolicy AbortPolicyThreadPoolExecutor中默认的拒绝策略就是AbortPolicy。直接抛出异常。 12private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 下面是他的实现： 12345678public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(&quot;Task &quot; + r.toString() + &quot; rejected from &quot; + e.toString()); &#125;&#125; 很简单粗暴，直接抛出个RejectedExecutionException异常，也不执行这个任务了。 测试先自定义一个Runnable,给每个线程起个名字，下面都用这个Runnable 123456789101112131415static class MyThread implements Runnable &#123; String name; public MyThread(String name) &#123; this.name = name; &#125; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;线程:&quot;+Thread.currentThread().getName() +&quot; 执行:&quot;+name +&quot; run&quot;); &#125; &#125; 然后构造一个核心线程是1，最大线程数是2的线程池。拒绝策略是AbortPolicy 1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 0, TimeUnit.MICROSECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new ThreadPoolExecutor.AbortPolicy()); 123456789for (int i = 0; i &lt; 6; i++) &#123; System.out.println(&quot;添加第&quot;+i+&quot;个任务&quot;); executor.execute(new MyThread(&quot;线程&quot;+i)); Iterator iterator = executor.getQueue().iterator(); while (iterator.hasNext())&#123; MyThread thread = (MyThread) iterator.next(); System.out.println(&quot;列表：&quot;+thread.name); &#125;&#125; 输出是： 分析一下过程。 添加第一个任务时，直接执行，任务列表为空。 添加第二个任务时，因为采用的LinkedBlockingDeque，，并且核心线程正在执行任务，所以会将第二个任务放在队列中，队列中有 线程2. 添加第三个任务时，也一样会放在队列中，队列中有 线程2，线程3. 添加第四个任务时，因为核心任务还在运行，而且任务队列已经满了，所以胡直接创建新线程执行第四个任务，。这时线程池中一共就有两个线程在运行了，达到了最大线程数。任务队列中还是有线程2， 线程3. 添加第五个任务时，再也没有地方能存放和执行这个任务了，就会被线程池拒绝添加，执行拒绝策略的rejectedExecution方法，这里就是执行AbortPolicy的rejectedExecution方法直接抛出异常。 最终，只有四个线程能完成运行。后面的都被拒绝了。 CallerRunsPolicyCallerRunsPolicy在任务被拒绝添加后，会调用当前线程池的所在的线程去执行被拒绝的任务。 下面说他的实现： 12345678public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; 也很简单，直接run。 测试1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new ThreadPoolExecutor.AbortPolicy()); 按上面的运行，输出 注意在添加第五个任务，任务5 的时候，同样被线程池拒绝了，因此执行了CallerRunsPolicy的rejectedExecution方法，这个方法直接执行任务的run方法。因此可以看到任务5是在main线程中执行的。 从中也可以看出，因为第五个任务在主线程中运行，所以主线程就被阻塞了，以至于当第五个任务执行完，添加第六个任务时，前面两个任务已经执行完了，有了空闲线程，因此线程6又可以添加到线程池中执行了。 这个策略的缺点就是可能会阻塞主线程。 DiscardPolicy这个策略的处理就更简单了，看一下实现就明白了： 12345public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; 这个东西什么都没干。 因此采用这个拒绝策略，会让被线程池拒绝的任务直接抛弃，不会抛异常也不会执行。 测试1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new ThreadPoolExecutor.DiscardPolicy()); 输出： 可以看到 后面添加的任务5和6根本不会执行，什么反应都没有，直接丢弃。 DiscardOldestPolicyDiscardOldestPolicy策略的作用是，当任务呗拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。 123456789public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; 在rejectedExecution先从任务队列总弹出最先加入的任务，空出一个位置，然后再次执行execute方法把任务加入队列。 测试1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new ThreadPoolExecutor.DiscardOldestPolicy()); 输出是： 可以看到， 在添加第五个任务时，会被线程池拒绝。这时任务队列中有 任务2，任务3 这时，拒绝策略会让任务队列中最先加入的任务弹出，也就是任务2. 然后把被拒绝的任务5添加人任务队列，这时任务队列中就成了 任务3，任务5. 添加第六个任务时会因为同样的过程，将队列中的任务3抛弃，把任务6加进去，任务队列中就成了 任务5，任务6 因此，最终能被执行的任务只有1，4，5，6. 任务2和任务3倍抛弃了，不会执行。 自定义拒绝策略通过看前面的系统提供的四种拒绝策略可以看出，拒绝策略的实现都非常简单。比如现在想让被拒绝的任务在一个新的线程中执行，可以这样写： 123456static class MyRejectedExecutionHandler implements RejectedExecutionHandler &#123; @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; new Thread(r,&quot;新线程&quot;+new Random().nextInt(10)).start(); &#125;&#125; 然后正常使用： 1234ThreadPoolExecutor executor = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2), new MyRejectedExecutionHandler()); 输出： 发现被拒绝的任务5和任务6都在新线程中执行了。]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程-线程池ThreadPoolExecutor]]></title>
    <url>%2F2018%2F01%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[为什么用线程池有时候，系统需要处理非常多的执行时间很短的请求，如果每一个请求都开启一个新线程的话，系统就要不断的进行线程的创建和销毁，有时花在创建和销毁线程上的时间会比线程真正执行的时间还长。而且当线程数量太多时，系统不一定能受得了。 使用线程池主要为了解决一下几个问题： 通过重用线程池中的线程，来减少每个线程创建和销毁的性能开销。 对线程进行一些维护和管理，比如定时开始，周期执行，并发数控制等等。 执行耗时的任务 ExecutorExecutor是一个接口，跟线程池有关的基本都要跟他打交道。下面是常用的ThreadPoolExecutor的关系。 Executor接口很简单，只有一个execute方法。ExecutorService是Executor的子接口，增加了一些常用的对线程的控制方法，之后使用线程池主要也是使用这些方法。AbstractExecutorService是一个抽象类。ThreadPoolExecutor就是实现了这个类。 ThreadPoolExecutor构造方法ThreadPoolExecutor是线程池的真正实现，他通过构造方法的一系列参数，来构成不同配置的线程池。常用的构造方法有下面四个： 12345ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 123456ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) 123456ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) 1234567ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 构造方法参数说明 corePoolSize 核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。除非将allowCoreThreadTimeOut设置为true。 maximumPoolSize 线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效。 keepAliveTime 非核心线程的闲置超时时间，超过这个时间就会被回收。 unit 指定keepAliveTime的单位，如TimeUnit.SECONDS。当将allowCoreThreadTimeOut设置为true时对corePoolSize生效。 workQueue 线程池中的任务队列. 常用的有三种队列，SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue。 threadFactory 线程工厂，提供创建新线程的功能。ThreadFactory是一个接口，只有一个方法 123public interface ThreadFactory &#123; Thread newThread(Runnable r);&#125; 通过线程工厂可以对线程的一些属性进行定制。默认的工厂： 12345678910111213141516171819202122232425static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager var1 = System.getSecurityManager(); this.group = var1 != null?var1.getThreadGroup():Thread.currentThread().getThreadGroup(); this.namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;; &#125; public Thread newThread(Runnable var1) &#123; Thread var2 = new Thread(this.group, var1, this.namePrefix + this.threadNumber.getAndIncrement(), 0L); if(var2.isDaemon()) &#123; var2.setDaemon(false); &#125; if(var2.getPriority() != 5) &#123; var2.setPriority(5); &#125; return var2; &#125;&#125; RejectedExecutionHandler RejectedExecutionHandler也是一个接口，只有一个方法 123public interface RejectedExecutionHandler &#123; void rejectedExecution(Runnable var1, ThreadPoolExecutor var2);&#125; 当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution方法。 线程池规则线程池的线程执行规则跟任务队列有很大的关系。 下面都假设任务队列没有大小限制： 如果线程数量&lt;=核心线程数量，那么直接启动一个核心线程来执行任务，不会放入队列中。 如果线程数量&gt;核心线程数，但&lt;=最大线程数，并且任务队列是LinkedBlockingDeque的时候，超过核心线程数量的任务会放在任务队列中排队。 如果线程数量&gt;核心线程数，但&lt;=最大线程数，并且任务队列是SynchronousQueue的时候，线程池会创建新线程执行任务，这些任务也不会被放在任务队列中。这些线程属于非核心线程，在任务完成后，闲置时间达到了超时时间就会被清除。 如果线程数量&gt;核心线程数，并且&gt;最大线程数，当任务队列是LinkedBlockingDeque，会将超过核心线程的任务放在任务队列中排队。也就是当任务队列是LinkedBlockingDeque并且没有大小限制时，线程池的最大线程数设置是无效的，他的线程数最多不会超过核心线程数。 如果线程数量&gt;核心线程数，并且&gt;最大线程数，当任务队列是SynchronousQueue的时候，会因为线程池拒绝添加任务而抛出异常。 任务队列大小有限时 当LinkedBlockingDeque塞满时，新增的任务会直接创建新线程(非核心线程)来执行，当创建的线程数量超过最大线程数量时会抛异常。 SynchronousQueue没有数量限制。因为他根本不保持这些任务，而是直接交给线程池去执行。当任务数量超过最大线程数时会直接抛异常。 规则验证前提所有的任务都是下面这样的，睡眠两秒后打印一行日志： 123456789101112Runnable myRunnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + " run"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;; 所有验证过程都是下面这样，先执行三个，再执行三个，8秒后，各看一次信息 12345678910111213141516171819executor.execute(myRunnable);executor.execute(myRunnable);executor.execute(myRunnable);System.out.println("---先开三个---");System.out.println("核心线程数" + executor.getCorePoolSize());System.out.println("线程池数" + executor.getPoolSize());System.out.println("队列任务数" + executor.getQueue().size());executor.execute(myRunnable);executor.execute(myRunnable);executor.execute(myRunnable);System.out.println("---再开三个---");System.out.println("核心线程数" + executor.getCorePoolSize());System.out.println("线程池数" + executor.getPoolSize());System.out.println("队列任务数" + executor.getQueue().size());Thread.sleep(8000);System.out.println("----8秒之后----");System.out.println("核心线程数" + executor.getCorePoolSize());System.out.println("线程池数" + executor.getPoolSize());System.out.println("队列任务数" + executor.getQueue().size()); 验证1 核心线程数为6，最大线程数为10。超时时间为5秒 1ThreadPoolExecutor executor = new ThreadPoolExecutor(6, 10, 5, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); 123456789101112131415161718---先开三个---核心线程数6线程池线程数3队列任务数0---再开三个---核心线程数6线程池线程数6队列任务数0pool-1-thread-1 runpool-1-thread-6 runpool-1-thread-5 runpool-1-thread-3 runpool-1-thread-4 runpool-1-thread-2 run----8秒之后----核心线程数6线程池线程数6队列任务数0 可以看到每个任务都是是直接启动一个核心线程来执行任务，一共创建了6个线程，不会放入队列中。8秒后线程池还是6个线程，核心线程默认情况下不会被回收，不收超时时间限制。 验证2 核心线程数为3，最大线程数为6。超时时间为5秒,队列是LinkedBlockingDeque 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 6, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;()); 123456789101112131415161718---先开三个---核心线程数3线程池线程数3队列任务数0---再开三个---核心线程数3线程池线程数3队列任务数3pool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 runpool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 run----8秒之后----核心线程数3线程池线程数3队列任务数0 当任务数超过核心线程数时，会将超出的任务放在队列中，只会创建3个线程重复利用。 验证3 核心线程数为3，最大线程数为6。超时时间为5秒,队列是SynchronousQueue 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 6, 5, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); 123456789101112131415161718---先开三个---核心线程数3线程池线程数3队列任务数0---再开三个---核心线程数3线程池线程数6队列任务数0pool-1-thread-2 runpool-1-thread-3 runpool-1-thread-6 runpool-1-thread-4 runpool-1-thread-5 runpool-1-thread-1 run----8秒之后----核心线程数3线程池线程数3队列任务数0 当队列是SynchronousQueue时，超出核心线程的任务会创建新的线程来执行，看到一共有6个线程。但是这些线程是费核心线程，收超时时间限制，在任务完成后限制超过5秒就会被回收。所以最后看到线程池还是只有三个线程。 验证4 核心线程数是3，最大线程数是4，队列是LinkedBlockingDeque 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;()); 123456789101112131415161718---先开三个---核心线程数3线程池线程数3队列任务数0---再开三个---核心线程数3线程池线程数3队列任务数3pool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 runpool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 run----8秒之后----核心线程数3线程池线程数3队列任务数0 LinkedBlockingDeque根本不受最大线程数影响。但是当LinkedBlockingDeque有大小限制时就会受最大线程数影响了 4.1 比如下面，将队列大小设置为2. 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(2)); 123456789101112131415161718---先开三个---核心线程数3线程池线程数3队列任务数0---再开三个---核心线程数3线程池线程数4队列任务数2pool-1-thread-2 runpool-1-thread-1 runpool-1-thread-4 runpool-1-thread-3 runpool-1-thread-1 runpool-1-thread-2 run----8秒之后----核心线程数3线程池线程数3队列任务数0 首先为三个任务开启了三个核心线程1，2，3，然后第四个任务和第五个任务加入到队列中，第六个任务因为队列满了，就直接创建一个新线程4，这是一共有四个线程，没有超过最大线程数。8秒后，非核心线程收超时时间影响回收了，因此线程池只剩3个线程了。 4.2 将队列大小设置为1 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(1)); 12345678910111213141516171819Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.sunlinlin.threaddemo.Main$1@677327b6 rejected from java.util.concurrent.ThreadPoolExecutor@14ae5a5[Running, pool size = 4, active threads = 4, queued tasks = 1, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at com.sunlinlin.threaddemo.Main.main(Main.java:35) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)---先开三个---核心线程数3线程池线程数3队列任务数0pool-1-thread-1 runpool-1-thread-2 runpool-1-thread-3 runpool-1-thread-4 runpool-1-thread-1 run 直接出错在第6个execute方法上。因为核心线程是3个，当加入第四个任务的时候，就把第四个放在队列中。加入第五个任务时，因为队列满了，就创建新线程执行，创建了线程4。当加入第六个线程时，也会尝试创建线程，但是因为已经达到了线程池最大线程数，所以直接抛异常了。 验证5 核心线程数是3 ，最大线程数是4，队列是SynchronousQueue 1ThreadPoolExecutor executor = new ThreadPoolExecutor(3, 4, 5, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); 123456789101112131415161718Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.sunlinlin.threaddemo.Main$1@14ae5a5 rejected from java.util.concurrent.ThreadPoolExecutor@7f31245a[Running, pool size = 4, active threads = 4, queued tasks = 0, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at com.sunlinlin.threaddemo.Main.main(Main.java:34) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)---先开三个---核心线程数3线程池线程数3队列任务数0pool-1-thread-2 runpool-1-thread-3 runpool-1-thread-4 runpool-1-thread-1 run 这次在添加第五个任务时就报错了，因为SynchronousQueue各奔不保存任务，收到一个任务就去创建新线程。所以第五个就会抛异常了。]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 获取 View 宽高的方式]]></title>
    <url>%2F2017%2F12%2F18%2FAndroid-%E8%8E%B7%E5%8F%96-View-%E5%AE%BD%E9%AB%98%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言在Android系统中，如果在 onCreate() 或 onResume() 生命周期方法中通过 getWidth() 之类的方法获取 View 的宽高值，那结果肯定是 0。这需要我们去了解一下View的绘制流程，View 需要onMeasure、onLayout、onDraw 三个过程才会真正画出来，执行onMeasure后可以得到 mMeasuredWidth、mMeasuredHeight， 执行onLayout 后可以得到 mLeft、mTop、mRight、mBottom 四个值，getWidth和getHeight就是通过这四个值计算的，如果我们在onCreate() 或 onResume() 中获取View 的宽高值，由于此时View还没measure\layout\draw，所以此时获取的就是0。在measure\layout\draw的每个过程都有方法获取View 的宽高值，下面一一介绍。 View#measure 获取宽高我们可以直接调用 View.measure 来获取 mMeasuredWidth与mMeasuredHeight，但是这个测量宽高可能与实际宽高不一致。getMeasuredWidth() 与 getMeasuredHeight() 获取的是mMeasuredWidth与mMeasuredHeight，这是在 measure 过程计算出来的测量宽高，而 getWidth() 与 getHeight() 是在 layout 过程之后计算出来的宽高。我们知道 View 的宽高是由 View 本身和 parent 容器共同决定的。mMeasuredWidth与mMeasuredHeight是View 本身的size，但是如果 parent 容器 没有足够大，View就不得不降低自己的尺寸。比如，View 通过自身 measure() 方法向 parent 请求 100x100 的宽高，那么这个宽高就是 measuredWidth 和 measuredHeight 值。但是，在 parent 的 onLayout() 阶段，通过 childview.layout() 方法只分配给 childview 50x50 的宽高。那么，这个 50x50 宽高就是 childview 实际绘制并显示到屏幕的宽高，也就是 width 和 height 值。 如果view是match_parent，理论上需要父view的size，即父View的剩余空间，所以我们需要在measure时传递正确的父View的Size，而如果在初始化阶段，父view的size也很难确定，那理论上这种情况是测量不出view的size。 如果view宽高是具体的数值，比如 100x100px，那可以如下measure : 123int widthMeasureSpec = MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int heightMeasureSpec = MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);view.measure(widthMeasureSpec, heightMeasureSpec); 如果view宽高是wrap_content，理论上可以用View能支持的最大值去构造MeasureSpec ，然后再measure出view的宽高 : 123int widthMeasureSpec = View.MeasureSpec.makeMeasureSpec((1 &lt;&lt; 30) - 1, View.MeasureSpec.AT_MOST); int heightMeasureSpec = View.MeasureSpec.makeMeasureSpec((1 &lt;&lt; 30) - 1, View.MeasureSpec.AT_MOST); view.measure(widthMeasureSpec, heightMeasureSpec); 综上所述，利用measure 需要考虑多种情况，而且最终得到的是mMeasuredWidth、mMeasuredHeight，还不一定与 getWidth() 、getHeight()相同，所以这种方式不推荐。 View#onLayout 获取宽高上面说过要想拿到真正的宽高值，就要在 onLayout之后去获取，对于自定义的View，可以重写 onLayout() 并在此函数中获取宽高：12345678view = new View(this) &#123; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); int width = view.getWidth(); int height = view.getHeight(); &#125;&#125;; View#OnLayoutChangeListener() 获取宽高 View一旦 layout 变化的时候，立即回调 onLayoutChange 方法：12345678view.addOnLayoutChangeListener(new View.OnLayoutChangeListener() &#123; @Override public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) &#123; view.removeOnLayoutChangeListener(this); int width = view.getWidth(); int height = view.getHeight(); &#125;&#125;); ViewTreeObserver#addOnGlobalLayoutListener() 获取宽高ViewTreeObserver 可以监听 View 的全局变化事件。比如，layout 变化，draw 事件等。当 layout 变化 就会回调 OnGlobalLayoutListener：123456789101112view.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; if (Build.VERSION.SDK_INT &gt;= 16) &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); &#125;else &#123; view.getViewTreeObserver().removeGlobalOnLayoutListener(this); &#125; int width = view.getWidth(); int height = view.getHeight(); &#125;&#125;); ViewTreeObserver#addOnGlobalLayoutListener与View#OnLayoutChangeListener有些许不同，对于View#OnLayoutChangeListener官方文档是这么说的 ： Interface definition for a callback to be invoked when the layout bounds of a view changes due to layout processing. 对于ViewTreeObserver#addOnGlobalLayoutListener官方文档是这么说的 ： Interface definition for a callback to be invoked when the global layout state or the visibility of views within the view tree changes. 从中可以发现在view本身的layout时才会回调OnLayoutChangeListener。而对于OnGlobalLayoutListener, 不管view本身或其父view的layout时都会回调。 ViewTreeObserver#OnPreDrawListener() 获取宽高OnPreDrawListener是在draw之前的回调，此时已经 layout 过，可以获取到 View 的宽高值。OnPreDrawListener还可以控制绘制流程，返回false的时候就取消当前绘制流程，View会再schedule下一次绘制：123456789view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123; @Override public boolean onPreDraw() &#123; view.getViewTreeObserver().removeOnPreDrawListener(this); int width = view.getWidth(); int height = view.getHeight(); return true; &#125;&#125;); view#post() 获取宽高1234567view.post(new Runnable() &#123; @Override public void run() &#123; int width = view.getWidth(); int height = view.getHeight(); &#125;&#125;); 为什么这个函数可以获取宽高值，就需要了解一下View的绘制流程，在onResume之前view.post的时候，会把Runnable添加到一个RunQueue中，在 onResume的时候 DecorView 会被添加到 ViewRoomImpl，之后会向主线程的消息队列发送一个绘制消息 TraversalRunnable，当执行到这个绘制消息的时候就会执行ViewRoomImpl.performTraversals()，ViewRoomImpl.performTraversals()先绘制整个DecorView，然后执行RunQueue中的消息，所以执行 view.post 的消息会在draw流程之后执行。 Activity#onWindowFocusChanged() 获取宽高当整个DecorView已经绘制完成，Activty已经要显示出来的时候，就会回调Activity#onWindowFocusChanged。123456@Overridepublic void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); int width = view.getWidth(); int height = view.getHeight();&#125; 参考 Android 获取 View 宽高的常用正确方式 调用view.measure(0,0)时发生了什么]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非主线程中更新UI的方式对比]]></title>
    <url>%2F2017%2F12%2F11%2F%E9%9D%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%9B%B4%E6%96%B0UI%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[前言我们知道Android中如果需要更新UI是需要运行在主线程中，如果我们在子线程中执行View.invalidate，那会报错。为什么一定要在主线程中才能更新 UI 呢？因为渲染UI的任务是在RenderThread中，如果所有线程都能与RenderThread通信，那肯定会涉及到线程同步和线程安全问题，会影响更新效率。Android中在非主线程更新UI的方式有很多种，下面一一介绍。 runOnUiThreadrunOnUiThread是Activity中的一个可以在主线程中运行代码的函数，查看源码可以知道，其会先判断是否在主线程，如果是就立即执行，如果不是就会添加到主线程的消息队列中 ：12345678final Handler mHandler = new Handler();public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125;&#125; Handler.postHandler 其实是作为多线程通信的工具，所以创建Handler 的时候要注意是在什么线程中创建，如果在非主线程中创建Handler 要先初始化Looper。利用Hander更新UI其实也是把任务添加到主线程的消息队列中，因为在创建Handler的时候会获取当前线程的Looper来初始化自己：12345678910public Handler(Callback callback, boolean async) &#123; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; AsyncTask在AsyncTask中有几个重要的函数 ： onPreExecute、onPostExecute、onProgressUpdate、doInBackground。其中onPreExecute、onPostExecute、onProgressUpdate是运行在主线程的。通过查看 AsyncTask的源码可知，AsyncTask中有个InternalHandler 专门处理回调，也就是说AsyncTask是建立在 ThreadPoolExecutor 和 Handler 的基础上的，也就是运行在主线程的回调都是post任务到Hander上执行的。1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; View.postView.post 在 SDK23 和 SDK24中的处理方式不一样，比如在SDK 23中的源码 ：123456789public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; // Assume that post will succeed later ViewRootImpl.getRunQueue().post(action); return true;&#125; 在Android 7.0 (SDK 24)中的源码 ：1234567891011public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; // Postpone the runnable until we know on which thread it needs to run. // Assume that the runnable will be successfully placed after attach. getRunQueue().post(action); return true;&#125; 相同点是在post前都会检查AttachInfo 是否为null，如果不是null就会通过attachInfo.mHandler来post任务。这个AttachInfo 是在View.dispatchAttachedToWindow中设置的 ：123void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; mAttachInfo = info; ... View 的dispatchAttachedToWindow 是由 ViewGroup 调用 ：1234567891011121314151617181920@Overridevoid dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; super.dispatchAttachedToWindow(info, visibility); mGroupFlags &amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) &#123; final View child = children[i]; child.dispatchAttachedToWindow(info, combineVisibility(visibility, child.getVisibility())); &#125; final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size(); for (int i = 0; i &lt; transientCount; ++i) &#123; View view = mTransientViews.get(i); view.dispatchAttachedToWindow(info, combineVisibility(visibility, view.getVisibility())); &#125;&#125; 那么又是谁调用了ViewGroup.dispatchAttachedToWindow，在ViewRootImpl.performTraversals中我们可以发现 ：1234567891011121314private void performTraversals() &#123; ... if (mFirst) &#123; ... if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123; host.setLayoutDirection(mLastConfiguration.getLayoutDirection()); &#125; host.dispatchAttachedToWindow(mAttachInfo, 0); mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); //Log.i(mTag, "Screen on initialized: " + attachInfo.mKeepScreenOn); &#125; ...&#125; 这个host 其实就是 Activity 的 DecorView，所以这里有两点结论： 只有在ViewRootImpl.performTraversals之后，AttachInfo 才被设置，也就是说ViewRootImpl.performTraversals之后，View.post的任务才会在添加到主线程的消息队列中 只有是DecorView 的子 View才会去设置这个View的AttachInfo，这一点很重要，因为我们可能会在代码中直接 new一个View，如果这个View不添加到 DecorView ，那么他的AttachInfo会一直为null。 回到刚才的问题，如果是AttachInfo 为null 的情况，在SDK23 的时候会通过ViewRootImpl.getRunQueue().post(action); 来执行任务。ViewRootImpl.getRunQueue 源码如下 ：123456789static HandlerActionQueue getRunQueue() &#123; HandlerActionQueue rq = sRunQueues.get(); if (rq != null) &#123; return rq; &#125; rq = new HandlerActionQueue(); sRunQueues.set(rq); return rq;&#125; 其实就是把任务都添加到HandlerActionQueue中，等到ViewRootImpl.performTraversals的时候才执行HandlerActionQueue的任务：123456 private void performTraversals() &#123; ... // Execute enqueued actions on every traversal in case a detached view enqueued an action getRunQueue().executeActions(mAttachInfo.mHandler);... &#125; 在Android 7.0 (SDK 24)的时候呢，任务会被 getRunQueue().post(action); 来执行 ,View.getRunQueue()源码如下：123456789101112131415161718 private HandlerActionQueue getRunQueue() &#123; if (mRunQueue == null) &#123; mRunQueue = new HandlerActionQueue(); &#125; return mRunQueue; &#125;``` 可见View中的HandlerActionQueue 与ViewRootImpl是同一个数据结构，那么View中的在什么时候执行呢，前面说了，是在dispatchAttachedToWindow 的时候 ：```java void dispatchAttachedToWindow(AttachInfo info, int visibility) &#123; ... // Transfer all pending runnables. if (mRunQueue != null) &#123; mRunQueue.executeActions(info.mHandler); mRunQueue = null; &#125; ... &#125; 所以在Android 7.0 (SDK 24)的时候，在AttachInfo为null的时候，任务会被添加到 View自己的RunQueue中，等到View.dispatchAttachedToWindow的时候才执行。而且View.RunQueue 比ViewRootImpl.RunQueue 先执行。这里要注意一点，只有DecorView 的子View才会被执行dispatchAttachedToWindow ，也就是说只有添加到DecorView的View才会执行这个View的RunQueue。 View.postInvalidateView.postInvalidate 也可以在子线程中去更新 UI ，其源码如下 :123456789101112public void postInvalidate(int left, int top, int right, int bottom) &#123; postInvalidateDelayed(0, left, top, right, bottom);&#125;public void postInvalidateDelayed(long delayMilliseconds) &#123; // We try only with the AttachInfo because there's no point in invalidating // if we are not attached to our window final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds); &#125;&#125; 也就是说在attachInfo不为 null的时候才会把任务添加到主线程的消息队列中。 思考问题在下面这段代码中，你知道打印的顺序是什么吗？12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); View v = new View(this); v.post(new Runnable() &#123; @Override public void run() &#123; Log.d("Test", "A custom view.post"); &#125; &#125;); findViewById(R.id.activity_main).post(new Runnable() &#123; @Override public void run() &#123; Log.d("Test", "B findViewById view.post"); &#125; &#125;); new Handler().post(new Runnable() &#123; @Override public void run() &#123; Log.d("Test", "C Handler.post"); &#125; &#125;); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Log.d("Test", "D main Thread runOnUiThread"); &#125; &#125;); new Thread(new Runnable() &#123; @Override public void run() &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Log.d("Test", "E sub Thread runOnUiThread"); &#125; &#125;); &#125; &#125;).start();&#125; 我们知道 在这些方式中，runOnUiThread会检查是否在主线程，所以D 会首先执行，如果runOnUiThread不在主线程执行，会把任务添加到 Handler的消息队列（主线程消息队列）中，在前面的分析中可以知道，view.post的任务会在ViewRootImpl.performTraversals时才执行，所以执行顺序是DCE。在onCreate中，此时View的AttachInfo肯定为null，所以第一个view.post在SDK 23时会添加到 ViewRootImpl的RunQueue中，在SDK 24时会添加到View自己的RunQueue中，由于没有添加到DecorView所以不会执行，所以在执行顺序是 DCEBA（SDK 23） 或 DCEB（SDK 24）。 在SDK 23的系统中运行结果是 ：12345Test : D main Thread runOnUiThreadTest : C Handler.postTest : E sub Thread runOnUiThreadTest : B findViewById view.postTest : A custom view.post 在SDK 24的系统中运行结果是 ：1234Test : D main Thread runOnUiThreadTest : C Handler.postTest : E sub Thread runOnUiThreadTest : B findViewById view.post 总结更新 UI 的各种方式有以下几种，从中可以发现，其实所有方式都是基于Handler来实现的： runOnUiThread 直接执行任务或通过Handler执行 Handler.post 添加到Handler消息队列 AsyncTask 通过Handler执行 View.post AttachInfo不为null时，直接用attachInfo.mHandler执行任务 AttachInfo为null时 : 在SDK23 的时候，任务会被添加到 ViewRootImpl的RunQueue中，等到ViewRootImpl.performTraversals的时候才执行 在Android 7.0 (SDK 24)的时候，任务会被添加到 View自己的RunQueue中，等到View.dispatchAttachedToWindow的时候才执行，View.RunQueue 比ViewRootImpl.RunQueue 先执行，只有添加到DecorView 的View 才会执行 View.postInvalidate 只有AttachInfo不为null的时候才会利用attachInfo.mHandler执行任务 参考 “只能在UI主线程更新View”这件小事]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法]]></title>
    <url>%2F2017%2F12%2F02%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言假设我们需要从 (1,1) 点出发到达 (4, 3)终点，如何计算出最短路径？ 我们的基本思路：篇历每一个点，找到每一条可达的路径，再找到路径中步数最少的一条。实现这种算法一般有两种方式：深度优先搜索与广度优先搜索。 1.深度优先搜索深度优先搜索是一种递归的算法。思路就是从一个点开始，篇历四个方向的四个点，每个点又篇历四周的四个点，直到找到目标点。首先定义一个方向数组：123456private int[][] next = &#123; &#123;0 , 1&#125;, //向右 &#123;1 , 0&#125;, //向下 &#123;0 , -1&#125;, //向左 &#123;-1 , 0&#125; // 向上&#125;; 通过这个方向数组可以方便计算下一个篇历的坐标 ：12345int nx, ny;for (int i = 0; i &lt; 3; i++) &#123; nx = x + next[i][0]; ny = y + next[i][1];&#125; 之后判断下一个点是否越界，是否是障碍物，是否已经访问过这个点 ，我们用 book数组来标记一点是否已访问，当book[nx][ny]为1时就已经访问，为0时未访问：123456789101112131415int nx, ny;for (int i = 0; i &lt; 3; i++) &#123; //计算下一个坐标 nx = x + next[i][0]; ny = y + next[i][1]; //判断是否越界 if (nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C) continue; //判断是否可访问 if (map[nx][ny] == 0 &amp;&amp; book[nx][ny] == 0) &#123; book[nx][ny] = 1; //标记这个点已经访问 dfs(nx, ny, step+1); //递归访问下一个点，step增加 book[nx][ny] = 0; //尝试结束，取消标记 &#125;&#125; 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DFSTest &#123; private int C, R; private int px, py; // 目标点 private int minStep = Integer.MAX_VALUE; // 最小步数，初始化为最大值 private int[][] map, book; private int[][] next = &#123; &#123; 0, 1 &#125;, // 向右 &#123; 1, 0 &#125;, // 向下 &#123; 0, -1 &#125;, // 向左 &#123; -1, 0 &#125; // 向上 &#125;; public DFSTest(int tx, int ty) &#123; C = 4; R = 5; px = tx; py = ty; map = MapFactory.createMap(R, C); book = new int[R][C]; &#125; public void dfs(int x, int y, int step) &#123; // 到达目标点，判断步数是否最小 if (x == px &amp;&amp; y == py) &#123; if (step &lt; minStep) minStep = step; return; // 此处返回很重要，不然会继续篇历 &#125; int nx, ny; for (int i = 0; i &lt; 3; i++) &#123; // 计算下一个坐标 nx = x + next[i][0]; ny = y + next[i][1]; // 判断是否越界 if (nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C) continue; // 判断是否障碍物，或已访问过 if (map[nx][ny] == 0 &amp;&amp; book[nx][ny] == 0) &#123; book[nx][ny] = 1; // 标记这个点已经访问 dfs(nx, ny, step + 1); // 递归访问下一个点，step增加 book[nx][ny] = 0; // 尝试结束，取消标记 &#125; &#125; &#125;&#125; 自定义的地图生成类 ：123456789101112131415private static class MapFactory &#123; public static int[][] createMap(int col, int row) &#123; return new int[][] &#123; &#123; 0, 0, 1, 0 &#125;, &#123; 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0 &#125;, &#123; 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 1 &#125; &#125;; &#125; public static void printMap(int[][] map, int col, int row) &#123; for (int i = 0; i &lt; row; i++) &#123; for (int j = 0; j &lt; col; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(""); &#125; &#125;&#125; 运行结果 ：12345678// 输入地图 ， C = 4 ， R = 5 ， 起始点 (0,0) ，目标点 (3, 2)0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1// 输出minStep=7 2.广度优先搜索广度优先搜索是一种篇历查询的算法。思路是从起始点开始，先篇历与起始点最近的四个方向的点（上下左右），再从这四个点，各篇历一次四个方向，通过这样一层层地搜索，直到找到目标点。我们先定义一个数据结构代码一个点 ：123456789101112public static class Node &#123; int x, y, step; public Node(int x, int y, int step) &#123; this.x = x; this.y = y; this.step = step; &#125; @Override public String toString() &#123; return "Node [x=" + x + ", y=" + y + ", step=" + step + "]"; &#125;&#125; 定义一个链表来保存每一个访问的点，并记录步数 ：12private int head, tail;private List&lt;Node&gt; queue = new ArrayList&lt;Node&gt;(); 其中的head、tail是算法关键点，head代表一个中心点的位置，tail 代表围绕这个中心点篇历各个方向的点时的位置 。第一步我们将(0, 0)添加到列表：12queue.add(new Node(x, y, 0));tail++; 然后从(0, 0)开始尝试向右(0, 1)，向下(1，0) 走下一步 ：此时(0, 0) head=0 这个点已经篇历完成，故从下一个点开始，head增加，并再次篇历各个方向的点 ：此时(0, 1)这个点篇历完毕，head自增走到(1, 0),并开始篇历 ：就这样head、tail不断前进篇历，直到找到目标点(3, 2)，此时步数为7：完整代码 ：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class WFSTest &#123; private int C,R; private int px , py; // 目标点 private int head, tail; private List&lt;Node&gt; queue = new ArrayList&lt;Node&gt;(); private int[][] map, book; private int[][] next = &#123; &#123; 0, 1 &#125;, // 向右 &#123; 1, 0 &#125;, // 向下 &#123; 0, -1 &#125;, // 向左 &#123; -1, 0 &#125; // 向上 &#125;; public WFSTest(int tx , int ty) &#123; C = 4; R = 5; px = tx; py = ty; map = MapFactory.createMap(R, C); MapFactory.printMap(map, C, R); book = new int[R][C]; &#125; public void wfs(int x, int y) &#123; boolean success = false; //起始点到列表中 book[x][y] = 1; queue.add(new Node(x, y, 0)); tail++; int nx, ny; while (head &lt; tail) &#123; Node h = queue.get(head); for (int i = 0; i &lt; 3; i++) &#123; // 计算下一个坐标 nx = h.x + next[i][0]; ny = h.y + next[i][1]; // 判断是否越界 if (nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C) continue; // 判断是否障碍物，或已访问过 if (map[nx][ny] == 0 &amp;&amp; book[nx][ny] == 0) &#123; book[nx][ny] = 1; queue.add(new Node(nx, ny, h.step + 1)); tail++; &#125; // 到达目标点 if (nx == px &amp;&amp; ny == py) &#123; success = true; break; &#125; &#125; // 已达目标点，退出循环 if (success) &#123; break; &#125; head++; &#125; &#125; public static class Node &#123; int x, y, step; public Node(int x, int y, int step) &#123; this.x = x; this.y = y; this.step = step; &#125; @Override public String toString() &#123; return "Node [x=" + x + ", y=" + y + ", step=" + step + "]"; &#125; &#125;&#125; 运行结果 ：12345678// 输入地图 ， C = 4 ， R = 5 ， 起始点 (0,0) ，目标点 (3, 2)0 0 1 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1// 输出minStep=7 3.扩展如果我们把算法里的结束条件去掉，那么这两个搜索算法就是一种篇历全部元素的算法，比如可以篇历搜索哪个点的值最大最小。123456789101112131415161718192021222324252627282930313233343536373839404142434445//深度优先搜索public void dfs(int x, int y) &#123; int nx, ny; for (int i = 0; i &lt; 3; i++) &#123; nx = x + next[i][0]; ny = y + next[i][1]; if (nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C) continue; if (map[nx][ny] == 0 &amp;&amp; book[nx][ny] == 0) &#123; book[nx][ny] = 1; // 不用取消标记，因为我们只篇历 dfs(nx, ny); &#125; &#125;&#125;//广度优先搜索public void wfs(int x, int y) &#123; boolean success = false; //起始点到列表中 book[x][y] = 1; queue.add(new Node(x, y, 0)); tail++; int nx, ny; while (head &lt; tail) &#123; Node h = queue.get(head); for (int i = 0; i &lt; 3; i++) &#123; // 计算下一个坐标 nx = h.x + next[i][0]; ny = h.y + next[i][1]; // 判断是否越界 if (nx &lt; 0 || nx &gt;= R || ny &lt; 0 || ny &gt;= C) continue; // 判断是否障碍物，或已访问过 if (map[nx][ny] == 0 &amp;&amp; book[nx][ny] == 0) &#123; book[nx][ny] = 1; queue.add(new Node(nx, ny, h.step + 1)); tail++; System.out.println("dump-----------nx=" + nx + ", ny=" + ny); &#125; //去掉了结束条件 &#125; head++; &#125;&#125; 总结本文主要介绍利用深度优先搜索与广度优先搜索来解决最短路径的方法，其中深度优先搜索是一种递归的搜索，广度优先搜索通过一层一层地搜索。当然最短路径的解决方法还有很多种，具体可以看一下《啊哈！算法》这本书，里面介绍了很多有趣的算法。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解 Service]]></title>
    <url>%2F2017%2F10%2F08%2FAndroid-Service-%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[最近有个项目刚好使用了Service，特别是AIDL远程服务，经过这次项目对Service有了更好的理解，在这里作个总结。 Service 与 Thread的关系 Service 是系统组件，继承于 Context，可以方便调用Android其它组件，比如广播，Activity等；而Thread是 java类。 Service可以跨进程调用，比如AIDL远程服务，而Thread不行。 Service可以在后台运行，在后台运行时可以提高进程优先级为服务进程 ，减少被回收的几率；而Thread 进入后台就会变成后台进程或空进程，随时有可能被系统回收。 startService / bindService 混合使用 每一次调用 startService 都会回调onStartCommand，之后调用了stopService之后就会 destroy Service。即使有多个client启动服务，那调用一次stopService 就能 destroy Service 。通过这种方式还有一个好处就是Service可以通过调用 stopSelf 主动退出。 第一次调用bindService 的时候才会回调 onBind，如果有多个client连接服务，在最后一个client调用unbindService时才会回调 onUnbind，并destroy Service。 如果startService / bindService 混合使用 那Service的生命同期会怎样呢，其实只要记住以上的思路，这种问题很好理解。首先 startService 与 stopService 对应 ，没有stopService 之前不会 destroy Service ， bindService 与 unbindService对应 ，没有 unbindService 前也不会destroy Service。 为服务添加权限相信大家做的服务都是公共的，即所有应用都可以调用。但是如果我想我的服务只给特定的应用调用，应该如何设置呢？我们可以给服务添加权限。关于权限，Android系统给权限为了四个类别： 普通级： 这些权限并不能真正伤害到用户（比如更换壁纸），当程序需要这些权限是，开发者不需要指定程序会自动赋予这些权限。 危险级： 这些权限可能会带来真的伤害（比如打电话，打开网络链接等），如果要使用它们需要开发者在AndroidManifest.xml中声明对应的权限。 签名级： 如果应用使用的是相同的签名证书时，这些权限会自动授予给声明或者创建这些权限的程序。设计这一层级权限的目的是方便组件间数据共享。 签名/系统级： 和签名级一样，例外的是系统镜像是自动获取这些权限的，这一层级是专为设备制造商设计的。1&lt;uses-permission android:name="android.permission.custom.XXX"/&gt; 如果我们想让自己开发的Service只能被特定的Client调用，那就可以添加自定义的权限。比如危险级，我们可以在AndroidManifest.xml中声明对应的权限，只有应用也设置了这个权限，才能正常启动服务。 关于AIDL远程服务所谓的AIDL远程服务 就是运行在另一个进程的服务，平时我们调用的服务都运行在主线程。要使用AIDL服务就必须写AIDL接口，向外暴露接口就可以与远程服务进行交互了。对于AIDL有如下几个值得注意的地方： AIDL接口的函数都不支持重载，即函数名不能一样，即使函数参数个数不一样。 AIDL接口传递的参数只有是基本数据类型、String 和CharSequence、List 和 Map、实现android.os.Parcelable 接口的类。 既然AIDL是在另一个进程的服务，那客户端调用的AIDL接口是否堵塞？ 答案是肯定的。如果不加 oneway 修饰符，那客户端调用的接口都是堵塞的，但是oneway修饰符也有限制，就是oneway接口下面的方法都必须是返回void类型，不能返回其他类型的数据。 AIDL的接口如何升级？在做一个比较大型的项目，那项目会不断迭代，那就有可能增加、修改AIDL接口，那如何保证AIDL接口和老的接口不会混乱呢，根据我的经验有如下总结： 对于增删接口的情况。服务端增加函数并不影响客户端，相反客户端增加服务端没有的接口就会访问无效果，如果客户端增加接口有返回值就返回默认值。 对于接口增删参数的情况。因为AIDl是基于BInder实现数据传递的，而Binder是通过 Parcel 来传输对象的，所以Client与Server之间的参数传递依赖于参数的顺序，但是如果Client不传参数，Server有参数就会去Binder读取，结果读取出来就会是null，并且报错。参数有无对应关系如下： Server接口有参数 Server接口无参数 Server接口增加参数 Server接口减少参数 Client接口有参数 √ √ √ √ Client接口无参数 Χ（报错） √ / / Service管理多个客户端如果Service有多个客户端，如何安全地与它们通信呢？如何给各个客户端回调结果呢？ 在这里我要说说我在最近项目出现的一个问题，我在项目中要做一个公共的服务，类似于指纹解锁，其它应用通过调用我的服务来获取结果，我设计了start(callback), stop()两个接口，一开始我就用单回调的方式，即在代码中定义一个callback的属性，谁调用了start就把callback设置成谁，只有最后一个调用start的Client能够获得回调，代码如下 ：1234567private Callbak mCallback;public void start(Callback callback) &#123; this.mCallback = callback;&#125;public void stop() &#123; this.mCallback = null;&#125; 这种方式，在单个应用时是很有效的，在多个应用时，只要应用能按顺序执行start、stop 那这个接口的设计也没什么问题。但是事情没想象中那么简单，如果Client1调用了start，跟着Client2也调用了start，这时Client1 要stop，那会怎样，那整个服务都stop了。这个就是我设计的服务中出现的大问题，之后我想着为我的服务接口作一些改变，以适应这种多应用的不按顺序的调用 。我第一个想法就是用register、unregister的方式，用一个list收集所有的callback ，回调时可以轮循，stop时也可以通过判断list的个数，如果是小于等于1，那就执行stop ：123456789private List&lt;Callbak&gt; mCallbacks;public void start(Callback callback) &#123; mCallbacks.add(callback);&#125;public void stop(Callback callback) &#123; mCallbacks.remove(callback); if(list.size() &gt;= 1) return;&#125; 考虑到接口的升级，这个改动是最小的，只给stop添加了一个参数。但是这个方式也有毛病，我们服务对Callback的引用是强引用，如果Client异常退出了，那引用还在并且会越积越多，在回调的时候，也可能出现DeadObjectException的错误。通过网络查找资料，我找到了RemoteCallbackList，RemoteCallbackList也是一个列表，保存的是回调接口，使用Link-To-Death回调 （在Sevice中接受到这个Binder对象，并且使用 binder.linkToDeath()，注册一个DeathRecipient回调；实现DeathRecipient。当Client意外退出的时候，DeathRecipient.binderDied()将被回调，我们可以在这里释放相关的资源。）。最终代码如下：1234567891011121314151617181920private RemoteCallbackList&lt;Callback&gt; mCallbacks = new RemoteCallbackList&lt;&gt;();public void start(Callback callback) &#123; mCallbacks.register(callback);&#125;public void stop(Callback callback) &#123; mCallbacks.unregister(callback); if(mCallbacks.getBroadcastItem() &gt;= 1) return;&#125;private void notifyResult(String result) &#123; final int len = mCallbacks.beginBroadcast(); for (int i = 0; i &lt; len; i++) &#123; try &#123; mCallbacks.getBroadcastItem(i).onResult(result); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; mCallbacks.finishBroadcast();&#125; 使用Messenger 实现 Servie与Client端通信Messenger是基于Handler的，通过为Messenger添加Handler来传递处理数据，之后Service与Client的通信都是通过传递的Handler来进行。用这种方式可以不需要定义AIDL接口，也就不出现因为修改AIDl接口所造成的接口版本不对应的麻烦。Messenger的使用就是通过 Handler传递消息， 客户端send方法发送的是一个Message，这个Message.replyTo指向的是一个Messenger，Messenger又持有客户端的一个Binder对象（MessengerImpl），服务端正是利用这个Binder对象做的与客户端的通信。 如何判断Client/Server端已经断开程序运行可能因为系统原因进程意外退出，比如内存不足，程序RuntimeException。但是Binder对端可能不知道意外退出，如果此时再调用接口可能会发生异常。我们可以通过三种方式来检测远程对象是否存活： 调用远程方法的时候捕获RemoteException(DeadObjectException)。 调用IBinder的pingBinder()进行检测。pingBinder()方法会返回当前远程服务的状态（true|false） 实现IBinder.DeathRecipient接口回调。实现了IBinder.DeathRecipient接口的参数调用linkToDeath()方法，可以在binderDied的回调方法中处理中断逻辑。前面说的RemoteCallbackList类就是通过这种方式。 参考 RemoteCallbackList类使用方法 Android 基于Message的进程间通信 Messenger完全解析]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Recyclerview的缓存机制的理解]]></title>
    <url>%2F2017%2F08%2F14%2F%E5%85%B3%E4%BA%8ERecyclerview%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言Android新增的Recyclerview主要用于代替ListView。Recyclerview可扩展性强。 可以通过LayoutManager形成线性（横向与竖向）、网格、瀑布流布局。 通过OnItemTouchListener监听 Item 的事件，虽然比ListView.OnItemClickListener麻烦了点，但是可以实现更复杂的功能，比如item滑动。 提供了notifyItemInserted、notifyItemRemoved、notifyItemChanged、notifyItemMoved来提高局部刷新的效率。 没有ListView那种 HeaderView 和 FooterView , 但可以通过来 getItemViewType来生成不同的视图。 RecyclerView还定义了ViewHolder，配合RecyclerView.Adapter，封装重用ItemView的逻辑，还有四级缓存，效率大大增加。 Recyclerview的缓存类RecyclerView缓存基本上是通过三个内部类管理的，Recycler、RecycledViewPool和ViewCacheExtension。 Recycler用于管理已经废弃或者与RecyclerView分离的ViewHolder，为了方便理解这个类，整理了下面的资料，内部类的成员变量和他们的含义： 变量 作用 mChangedScrap 与RecyclerView分离的ViewHolder列表 mAttachedScrap 未与RecyclerView分离的ViewHolder列表 mCachedViews ViewHolder缓存列表 mViewCacheExtension 开发者可以控制的ViewHolder缓存的帮助类 mRecyclerPool ViewHolder缓存池 RecycledViewPoolRecycledViewPool类是用来缓存Item用，是一个ViewHolder的缓存池，如果多个RecyclerView之间用setRecycledViewPool(RecycledViewPool)设置同一个RecycledViewPool，他们就可以共享Item。其实RecycledViewPool的内部维护了一个Map，里面以不同的viewType为Key存储了各自对应的ViewHolder集合。可以通过提供的方法来修改内部缓存的Viewholder。 ViewCacheExtension开发者可自定义的一层缓存，是虚拟类ViewCacheExtension的一个实例，开发者可实现方法getViewForPositionAndType(Recycler recycler, int position, int type)来实现自己的缓存。 Recyclerview的四级缓存1.屏幕内缓存屏幕内缓存指在屏幕中显示的ViewHolder，这些ViewHolder会缓存在mAttachedScrap、mChangedScrap中 ： mChangedScrap 表示数据已经改变的ewHolder列表 mAttachedScrap 未与RecyclerView分离的ViewHolder列表 2.屏幕外缓存当列表滑动出了屏幕时，ViewHolder会被缓存在 mCachedViews ，其大小由mViewCacheMax决定，默认DEFAULT_CACHE_SIZE为2，可通过Recyclerview.setItemViewCacheSize()动态设置。 3.自定义缓存可以自己实现ViewCacheExtension类实现自定义缓存，可通过Recyclerview.setViewCacheExtension()设置。 4.缓存池ViewHolder在首先会缓存在 mCachedViews 中，当超过了个数（比如默认为2）， 就会添加到 RecycledViewPool 中。RecycledViewPool 会根据每个ViewType把ViewHolder分别存储在不同的列表中，每个ViewType最多缓存DEFAULT_MAX_SCRAP = 5 个ViewHolder，如果RecycledViewPool没有被多个RecycledView共享，对于线性布局，每个ViewType最多只有一个缓存，如果是网格有多少行就缓存多少个。他们之间的关系如下 : 缓存策略Recyclerview在获取ViewHolder时按四级缓存的顺序查找，如果没找到就创建。其中只有RecycledViewPool找到时才会调用 bindViewHolder，其它缓存不会重新bindViewHolder 。 流程如下 : 总结通过了解RecyclerView的四级缓存，我们可以知道，RecyclerView最多可以缓存 N（屏幕最多可显示的item数） + 2 (屏幕外的缓存) + 5*M (M代表M个ViewType，缓存池的缓存)，只有RecycledViewPool找到时才会重新调用 bindViewHolder。还需要注意的是，RecycledViewPool 可以被多个RecyclerView共享，其缓存个数与ViewType个数、布局相关，如果RecycledViewPool没有被多个RecycledView共享，对于线性布局，每个ViewType最多只有一个缓存，如果是网格布局有多少行就缓存多少个。 参考 RecyclerView 缓存机制详解 Android 踩坑记录（一）- Recyclerview的缓存机制 Android ListView与RecyclerView对比浅析–缓存机制 Anatomy of RecyclerView, Part 1 — a Search for a ViewHolder]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找二叉树两个节点的最近公共祖先]]></title>
    <url>%2F2017%2F08%2F08%2F%E5%AF%BB%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目实现 NearestCommonAncestor 函数 。要求寻找二叉树中两个节点的最近的公共祖先，并将其返回。12345678class Node &#123; Node * left; Node * right; Node * parent; &#125;; /*查找p，q的最近公共祖先并将其返回。*/ Node * NearestCommonAncestor(Node * p,Node * q); 算法思想：这道题的关键在于每个节点中包含指向父节点的指针，这使得程序可以用一个简单的算法实现。首先给出p的父节点p-&gt;parent，然后将q的所有父节点依次和p-&gt;parent作比较，如果发现两个节点相等，则该节点就是最近公共祖先，直接将其返回。如果没找到相等节点，则将q的所有父节点依次和p-&gt;parent-&gt;parent作比较……直到p-&gt;parent==root。程序代码：123456789101112131415Node * NearestCommonAncestor(Node * root,Node * p,Node * q) &#123; Node * temp; while(p!=NULL) &#123; p=p-&gt;parent; temp=q; while(temp!=NULL) &#123; if(p==temp-&gt;parent) return p; temp=temp-&gt;parent; &#125; &#125; &#125; 知识扩展如果节点中不包含指向父节点的指针应该怎么计算？算法思想：如果一个节点的左子树包含p，q中的一个节点，右子树包含另一个，则这个节点就是p，q的最近公共祖先。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*查找a，b的最近公共祖先，root为根节点，out为最近公共祖先的指针地址*/int FindNCA(Node* root, Node* a, Node* b, Node** out) &#123; if( root == null ) &#123; return 0; &#125; if( root == a || root == b ) &#123; return 1; &#125; int iLeft = FindNCA(root-&gt;left, a, b, out); if( iLeft == 2 ) &#123; return 2; &#125; int iRight = FindNCA(root-&gt;right, a, b, out); if( iRight == 2 ) &#123; return 2; &#125; if( iLeft + iRight == 2 ) &#123; *out = root; &#125; return iLeft + iRight;&#125;void main() &#123; Node* root = ...; Node* a = ...; Node* b = ...; Node* out = null; int i = FindNCA(root, a, b, &amp;out); if( i == 2 ) &#123; printf("Result pointer is %p", out); &#125; else &#123; printf("Not find pointer"); &#125; &#125; 参考 寻找二叉树两个节点的最近公共祖先]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何确定一个链表中有闭环?]]></title>
    <url>%2F2017%2F08%2F01%2F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%9C%89%E9%97%AD%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[利用两个指针p1,p2(每次分别增1和2)来进行判断使用两个指针 ： slow和fast ， slow每次移动一位，fast每次移动两位，当发生以下条件之一时结束，时间复杂度为O(n)。 首先一个终止的条件是指针p2遇到NULL节点.这说明不存在闭环 另外一个条件式当两个指针相遇就终止,这说明有闭环 为什么有环的情况下二者一定会相遇呢？因为fast先进入环，在slow进入之后，如果把slow看作在前面，fast在后面每次循环都向slow靠近1，所以一定会相遇，而不会出现fast直接跳过slow的情况。 12345678910111213141516171819202122232425//判断是否有环 bool isLoop(pNode pHead) &#123; pNode fast = pHead; pNode slow = pHead; //如果无环，则fast先走到终点 //当链表长度为奇数时，fast-&gt;Next为空 //当链表长度为偶数时，fast为空 while( fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; //如果有环，则fast会超过slow一圈 if(fast == slow) &#123; break; &#125; &#125; if(fast == NULL || fast-&gt;next == NULL ) return false; else return true; &#125; 计算环的长度如果有环两个指针相遇，那么在相遇后让fast不动，slow继续走，并开始计数，直到在两个指针重新相遇，这个长度就是环的长度。123456789101112131415161718192021222324252627282930int loopLength(pNode pHead) &#123; if(isLoop(pHead) == false) return 0; pNode fast = pHead; pNode slow = pHead; int length = 0; bool begin = false; bool agian = false; while( fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; //超两圈后停止计数，挑出循环 if(fast == slow &amp;&amp; agian == true) break; //超一圈后开始计数 if(fast == slow &amp;&amp; agian == false) &#123; begin = true; agian = true; &#125; //计数 if(begin == true) ++length; &#125; return length; &#125; 计算环的入口假设链表头是X，环的第一个节点是Y，slow和fast第一次的交点是Z。各段的长度分别是a,b,c，环的长度是L。如图所示 : 第一次相遇时slow走过的距离：a+b，fast走过的距离：a+b+c+b。因为fast的速度是slow的两倍，所以fast走的距离是slow的两倍，有 2(a+b) = a+b+c+b，可以得到a=c。我们发现L=b+c=a+b，也就是说，从一开始到二者第一次相遇，循环的次数就等于环的长度。我们已经得到了结论a=c，那么让两个指针分别从X和Z开始走，每次走一步，那么正好会在Y相遇！也就是环的第一个节点。1234567891011121314151617181920212223242526//求出环的入口点 Node* findLoopEntrance(pNode pHead) &#123; pNode fast = pHead; pNode slow = pHead; while( fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; //如果有环，则fast会超过slow一圈 if(fast == slow) &#123; break; &#125; &#125; if(fast == NULL || fast-&gt;next == NULL) return NULL; slow = pHead; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; &#125; 类似问题查找单链表中倒数第n个节点单向链表的特点是遍历到末尾后不能反向重数N个节点。因此必须在到达尾部的同时找到倒数第N个节点。通过一次遍历找到单链表中倒数第n个节点，链表可能相当大，可使用辅助空间，但是辅助空间的数目必须固定，不能和n有关。不管是顺数n个还是倒数n个，其实都是距离-标尺问题。标尺是一段距离可以用线段的两个端点来衡量，我们能够判断倒数第一个节点，因为他的next==NULL。如果我们用两个指针，并保持他们的距离为n，那么当这个线段的右端指向末尾节点时，左端节点就指向倒数第n个节点。12345678910111213141516171819202122232425262728293031323334353637383940414243444546iNode * GetLastNnode(iNode * head, int n)&#123; iNode * pfirst=head; iNode *psecond=head; int counter; //第1步：建立标尺，移动pfirst N步 for(counter=0; counter&lt;n; counter++) &#123; if((NULL == pfirst) break; // 此时pfirst-&gt;next无意义 pfirst=pfirst-&gt;next; &#125; if(n != counter) //长度不够n，未找到倒数第n个节点 return NULL; //第2步：保持距离让标尺向右移动，直到右端指向末尾，左端即结果 while(pfirst!=NULL) &#123; pfirst=pfirst-&gt;next; psecond=psecond-&gt;next; &#125; return psecond;&#125; iNode * GetLastNnode ( iNode *head, int n)&#123; iNode * pfirst = head; iNode * psecond = NULL;//可能没有n个 while( n-- &gt; 0 &amp;&amp; (pfirst!= NULL) &#123; pfirst = pfirst -&gt;next; &#125; if(pfirst!= NULL)// 有n个节点 psecond = head; while(pfirst!=NULL) &#123; pfirst = pfirst -&gt;next; psecond = psecond -&gt;next; &#125; return psecond; //只有一个出口，无论是否有n个节点，都能返回正确值&#125; 一次遍历单向链表找到中间节点和上面的思路类似，设置2个指针，一个走2步时，另一个走1步。那么一个走到头时，另一个走到中间。123456789101112131415iNode * GetMiddleNode ( iNode *head )&#123; iNode *p1 = head; iNode *p2 = p1; while( p2 ) &#123; p2 = p2-&gt;next; if(p2) &#123; p2 = p2-&gt;next; p1=p1-&gt;next; &#125; &#125; return p1;&#125; 参考 如何判断链表中是否有环 [算法][LeetCode]Linked List Cycle &amp; Linked List Cycle II——单链表中的环]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[转]Android 密钥保护和 C/S 网络传输安全理论指南]]></title>
    <url>%2F2017%2F07%2F19%2F%E8%BD%AC-Android-%E5%AF%86%E9%92%A5%E4%BF%9D%E6%8A%A4%E5%92%8C-C-S-%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E7%90%86%E8%AE%BA%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言这篇文章Android安全方面很清晰易懂，在此转载，原文链接 正文注：本文将着重讲解 Android KeyStore、so 库保护 app key / secret、HTTPS 原理及其防中间人攻击措施。 谈到 Android 安全性话题，Android Developers 官方网站给出了许多很好的建议和讲解，涵盖了存储数据、权限、网络、处理凭据、输入验证、处理用户数据、加密等方方面面，甚至对于动态加载代码也提供了建议，具体可以看看 training 的 security tips 章节。而今天，我想特别来讲一讲在 Android 密钥保护和 C/S 网络传输安全 这两方面的具体安全措施。 密钥的保护以及网络传输安全 应该是移动应用安全最关键的内容。 所谓的密钥，简单来说，可以认为是我们常用的 app key / secret / token 或数据加密的 key，这些 keys 就像我们宝库的钥匙，一旦泄露，就像大门被人撬开，什么安全都无从谈起。因此，密钥们的安全存储、防窃取便显得异常重要。我曾经看过许多国内外著名的应用在使用自家 API 或 SaaS 服务的时候，在 Java 代码或 SharePreferences 里明文记录着 app key / secret / token，这样的做法，就算使用了 proguard 对代码进行混淆，也是非常容易被逆向获得服务端接入密钥，非常危险。 在这一方面，Android 提供大量用来保护数据的加密算法，例如 Cipher 类中提供了 AES 和 RSA 算法，再例如安全随机数生成器 SecureRandom 给 KeyGenerator 提供了更加可靠的初始化参数，避免离线攻击等等。 而如果需要存储密钥以供重复使用，Android 提供了 KeyStore 等可以长期存储和检索加密密钥的机制，Android KeyStore 系统特别适合于存储加密密钥。”AndroidKeyStore” 是 KeyStore 的一个子集，存进 AndroidKeyStore 的 key 将受到签名保护，并且这些 key 是存在系统里的，而不是在 App 的 data 目录下，依托于硬件的 KeyChain 存储，可以做到 private key 一旦存入就无法取出，总之，每个 App 自己创建的 key，别的应用是访问不到的。 很多时候，我们会需要将用户的账号密码或 token 存储下来，以做到下次打开免登的目的。KeyStore 提供了两个能力： 生成随机加密密钥 安全存储和读取数据 有了这两个能力，我们的密钥保护就变得很容易了，你只需要： 在应用安装后第一次运行时，生成一个随机密钥，并存入 KeyStore 当你想存储一个数据，便从 KeyStore 中取出之前生成的随机密钥，对你的数据进行加密，加密完成后，已完成加密的数据可以随意存储在任意地方，比如 SharePreferences，此时即使它被他人读取到，也无法解密出你的原数据，因为他人取不到你的密钥 当你需要拿到你的原数据，只需要从 SharePreferences 中读取你加密后的数据，并从 KeyStore 取出加密密钥，使用加密密钥对 “加密后的数据” 进行解密即可 其中加密算法可以使用 Cipher AES 来保证安全性，不要使用自己创造的加密算法。这就是使用 KeyStore 的一整套流程，另外 KeyStore 还可以用来做数据签名和签名验证，就像一个黑匣子一样，具体可以自行搜索了解。 KeyStore 适用于生成和存储密钥，这些密钥可以用来加密运行时获取到的数据，比如运行时，用户输入的密码，或者服务端传下来的 token。但对于需要预设在 App 内的 API key / secret，因为 KeyStore 是运行时随机生成加密密钥，所以我们无法预估API key / secret 会被加密成什么样，自然也就无法预先把加密后的 API key / secret 预埋在 App 内，因此对于这类需要预设的固定密钥，我将介绍另外一种十分安全、难破解的保护方式。 首先我们需要思考，这个 key 应该放到哪里才能够最大限度提升其被逆向获取的难度，放 Java 代码里？根本不安全。放文件或图片像素里？顶多续 1 小时。放 so 库里？可以，so 库能够很大程度提升逆向破解难度，但如果别人把 so 库文件拿出来，再直接调用这些 native 接口，便也可以获取到你的 key，怎么办？ 我的做法是在 so 库的 C 代码里JNI_OnLoad()方法对 APK 签名进行验证，如果签名不对，直接 crash，这样移植出去便和砖头没什么两样。而你的应用又不得不依赖这个 so 库进行获取 API key / secret，因此它又不能直接剥离，这就保证了不能没有它，又不能移植它，换句话说就是：如果别人反编译了你的代码，发现你使用 so 进行签名验证，便直接把这个 so 文件摘掉，这样做的结果是，App 获取不到你存在 so 中的 secret 了，便无法正常工作了；而如果别人对你的应用进行修改和重新签名，或移植你的 so 库来读取内部的 secret，则会因为签名验证不通过直接自爆。 以上便是对于保护 key / secret 的一些有效举措，再总结下就是，使用 so 库存储预设 key / secret，使用 Android KeyStore 存储运行时动态获取到的私密内容。 而另一方面，对网络传输进行加密、防中间人攻击也是至关重要的，如果你的密钥保护得很好，但数据却在网络传输过程中被拦截篡改，那也是前功尽弃。 如果使用 HTTP，对于 API 请求参数会变的请求，一般都会进行参数防篡改校验，和参数加密，客户端和服务端会约定一个固定的密钥作为加密的 key，这个 key 便属于上面我们讲过的需要预设在 App 代码里的，因此比较安全的做法就是将它埋藏在 so 库里。 但更推荐、更简单的做法是，使用 HTTPS，HTTPS 是 HTTP 的安全版本，为什么这么说呢？因为HTTPS 自带加密、验签、检查数据完整性等功能，它在 HTTP 下加入了 SSL (Secure Socket Layer)，SSL 位于 TCP/IP 和 HTTP 协议之间，负责加密、验签、检查数据完整性工作。 HTTPS 的握手过程中能够确立客户端与服务端双方加密传输数据的密码信息，流程大致如下： 客户端将自己支持的加密算法类型和检验数据完整性的 HASH 算法类型告诉服务端 服务端从客户端传上来的加密算法中选出一种支持的类型，用于生成一对非对称密钥对，并将自己的证书发给客户端，证书中将带有这对非对称密钥的公钥和证书颁发机构、过期时间等。其中所谓的非对称加密及其公钥和密钥，如果不懂，可以简单理解为：这是一种加密算法，私钥加密的内容只有公钥才能解密，反之公钥加密的内容只有私钥才能解密，以此来保证两端信息的安全性。 客户端获得证书后，会对证书的合法性进行检验，如果证书合法，则客户端将随机生成一对称加密的密钥，并使用服务端给的非对称加密密钥对这个对称加密密钥进行加密，并生成 HASH 值，统一发给服务端。所谓对称加密及其密钥，简单说：这是一种加密算法，加密和解密使用的密钥是一样的。 服务端拿到信息后，使用私钥进行解密取出对称加密的密钥，并验证 HASH 值。验证无误后，使用这个对称加密密钥对握手信息进行加密，发给客户端。 客户端解密和 HASH 验证，无误则握手成功完成。接下来所有的通讯都会使用这个已经同步到两端的对称加密密钥进行加密通讯。而一旦这个握手过程中有任何错误，都会中止握手过程，请求的参数和内容传输是在这些过程之后，因此若是握手过程出错，则不会发送请求内容。 但是，尽管有了以上机制来保证端与端之间通信的安全，仍然无法保证安全，因为防不住中间人攻击，也就是说，如果有个中间人横跨在你的客户端与服务端之间，你以为你在和服务端握手，但实际上是在与这个中间人握手，这个中间人将持有你目标服务端的公钥，以及它自己产生的密钥和公钥，然后把它自己产生的公钥交给你，你以为你拿到手的是服务端直接给你的公钥，因此这个中间人能够解密你的所有请求。你的客户端 &lt;–&gt; Packet Capture/Charles（VPN 或 Wi-Fi 或代理，它们都算中间人） &lt;–&gt; 你的目标服务器 关于这个话题，我回答过一个 StackOverflow 问题，提问者不明白为什么他使用了 HTTPS，结果一个叫做 Packet Capture 的抓包工具居然还能获取到他的请求内容。实际上原理就是因为这个中间人替换掉了服务端的证书。 解决办法就是客户端要对服务端传下来的证书是否正确进行验证，如果使用 OkHttp 的话，可以预设服务端证书的 pining 值，通过 OkHttp Builder 的 certificatePinner 方法进行设置，非常简单。如此设置之后，一旦证书被替换掉，便与你预设的证书 pinning 不对等，握手过程就会中止，请求数据根本不会传输出去，这样中间人也就获取不到你的请求内容了。 除了设置 certificatePinner 的方法之外，还可以把服务端的证书的拷贝 完整地放在客户端一份，等服务端传下来的时候，对本地证书进行对比，若不对等，则抛出错误。对于 OkHttp，可以使用 OkHttpClient.Builder().sslSocketFactory(sslContext.getSocketFactory()) 来给它传递你的证书。 这么做以后，便可以防止网络传输过程中中间人获取你的加密信息。整个应用的基础安全措施也就到此实施结束了。值得一提的是，对于 HTTPS，很多人存在误解，以为 GET 请求是不安全的，POST 才是安全的，实际上，不仅仅 GET 的参数内容会被加密，你的 header、body 等等都是会被加密，都是安全的。 相关链接 OkHttp HTTPS wiki Android Developers 安全性和隐私权最佳实践 How do you encrypt / hide the body of an HTTPS call using Retrofit 2 + OkHttp 3? Securely Storing Secrets in an Android Application 当 OkHttp 遇到 Https(已过时，但里面很多原理很不错，关于 OkHttp 与 HTTPS 建议直接阅读第一个链接官方 wiki，非常可靠) Android KeyStore helper(一个很方便好用的开源库，作者还有很多很棒的加密相关开源产品)]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2 中容易混淆的函数]]></title>
    <url>%2F2017%2F07%2F01%2FRxJava2-%E4%B8%AD%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[create()、defer()、fromCallable()、fromFuture() create()：创建一个自定义的Obserable，需要自己实现onNext()、onError()、onComplete()的逻辑； defer()：这个方法很有用，defer操作符需要指定一个Obserable的工厂方法，然后它只会在有订阅者订阅它时才会创建Obserable，而且是为每个订阅者创建自己的Obserable； fromCallable()：与defer()相似，但是fromCallable()返回的是onNext传递的数据，而defer()返回的是新的Obserable。fromCallable()获取要发送的数据的代码只会在有Observer订阅之后执行，且获取数据的代码可以在子线程中执行。 fromFuture()：接收一个Future对象，会同步等待Future返回的结果再发送数据，也可以设置等待超时时间。 interval()、timer()、delay() interval()：创建一个按固定时间间隔发射整数序列的Observable，类似于TimerTask定时器的功能； timer()：新版本的timer()只是用来创建一个Observable，并延迟发送一次的操作符； delay()：延迟一段指定的时间再发送来自Observable的发送结果，常规使用跟timer()一致，区别在于delay()是用于流中的操作，跟map()、flatMap()的级别是一样的。而timer()是用于创建Observable，跟just()、from()的级别是一样的。 flatMap()、map() flatMap()：一般用于输出一个Observable，而其随后的subscribe中的参数也跟Observable中的参数一样，注意不是Observable，一般用于对原始数据返回一个Observable，这个Observable中数据类型可以是原来的，也可以是其他的； map()：一般用于对原始的参数进行加工处理，返回值还是基本的类型，可以在subscribe中使用(适用)的类型。 flatMap和map操作符很相像，flatMap发送的是合并后的Observables，map操作符发送的是应用函数后返回的结果集，也可以通俗地理解为flatMap用于转化Obserable，而map用于转化结果。 merge()、concat()、amb()、zip() merge()：将帮助你把两个甚至更多的Observables合并到他们发射的数据里。如果Observables运行在不同的线程，那发送的数据可能是交替的，即先接收到哪个Observable的数据就发送谁的数据； concat()：与merge()类似，同样是把两个甚至更多的Observables合并到他们发射的数据里。不同点在于concat()会按顺序发送数据，即第一个Observable发送完了数据才执行第二个Observable； amb()：对于给定两个或多个Observables，它只发射首先发射数据或通知的那个Observable的所有数据。也就是说amb()只会发送一个Obserable的数据，其它的会被取消； zip()：对于给定两个或多个Observables，它会把每个Obserable的数据按发送顺序组合并回调，让用户自己根据每个Obserable决定要发送的数据。 concatMap()、switchMap() concatMap()：concatMap()和flatMap()很像，但是flatMap()可能交错的发送事件，最终结果的顺序可能并是不原始Observable发送时的顺序，concatMap()操作符则可以保证按顺序发送结果集； switchMap()：switchMap()和flatMap()很像，除了一点:当源Observable发射一个新的数据项时，如果旧数据项订阅还未完成，就取消旧订阅数据和停止监视那个数据项产生的Observable,开始监视新的数据项； repeat()、repeatWhen()、repeatUtil() repeat()接收到.onCompleted()事件后触发重订阅。可以传递参数设定有限次数的重试； repeatWhen()：指示Observable遇到onCompleted()时，将结果传递给另一个Observable来决定是否要重新给订阅这个Observable； repeatUtil()：指示Observable遇到onCompleted()时，将结果传递给repeatUtil的回调函数决定是否要重新给订阅这个Observable，返回false重新订阅，返回true取消订阅。 retry()、retryWhen()、retryUtil() retry()接收到.onError()事件后触发重订阅。可以传递参数设定有限次数的重试； retryWhen()：指示Observable遇到错误时，将错误传递给另一个Observable来决定是否要重新给订阅这个Observable。 retryUtil()：指示Observable遇到onError()时，将结果传递给retryUtil的回调函数决定是否要重新给订阅这个Observable，返回false重新订阅，返回true取消订阅。 repeat()、retry()这些只能控制重新的次数，repeatUtil()、retryUtil()可以控制要不要重试，但是这些重新订阅都是Rxjava自动操作的，也就是你不能再改变订阅后的行为。比如如果你要实现一个延迟数秒的重订阅该如何去做？或者想通过观察错误来决定是否应该重订阅呢？这种情况下就需要.repeatWhen()和.retryWhen()； takeUtil()、skipUtil() takeUtil()：持续接收第一Obserable（调用takUtil的Obserable）发送的数据，当第二Obserable（takUtil参数中的Obserable）发送数据时两个Obserable会同时取消订阅。 skipUtil()：与takeUtil()正好相反，不接收第一Obserable（调用takUtil的Obserable）发送的数据，直到第二Obserable（takUtil参数中的Obserable）发送数据时才接收第一Obserable的数据，此时第二Obserable会取消订阅。 takeWhile()、skipWhile() takeWhile()：与takeUtil()类似，不过传递的不是Obserable，而是Predicate，用于判断是否接收数据，返回true就接收，返回false就不接收，一旦返回false这个Predicate也不会被调用了； skipWhile()：与skipUtil()类似，不过传递的不是Obserable，而是Predicate，用于判断是否接收数据，返回true就不接收，返回false就接收，一旦接收这个Predicate也不会被调用了； 参考 RxJava处理网络连接失败和timer()、interval()、delay()之间的区别 【译】对RxJava中.repeatWhen()和.retryWhen()操作符的思考 [Android开发] RxJava2之路七 - 错误处理操作符例子Demo]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinearLayout 中不得不说的几个重要属性]]></title>
    <url>%2F2017%2F06%2F17%2FLinearLayout-%E4%B8%AD%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[关于LinearLayoutLinearLayout 在布局使用中比较频繁，一般可以设置成horizontal（横向）、vertical（竖向）两个方向，不过LinearLayout还有如下几个重要的属性，了解这几个属性可以让我们更加全面地认识linearLayout的真正功能。 1、weight 属性weight属性意思是占比，就是占用的空间的大小，其实它的真正意义是剩余空间的占比。比如我们添加两个TextView，其中的text1添加android:layout_weight=&quot;1&quot;，text2添加android:layout_weight=&quot;2&quot;，如下设置：12345678910111213141516171819&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:background="#FF0000" android:text="text1" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="2" android:background="#00FF00" android:text="text2" /&gt;&lt;/LinearLayout&gt; 结果会发现text2的宽度差不多是text1的两倍。假设每个text的宽度是120px , 那么在1080P的屏幕上，刚开始剩余空间是840px，text1的weight占1，text2的weight占2，所以text1的宽度是 120 + 840 / 3 = 400px，text2的宽度是 120 + 840 * 2 / 3 = 680px ，text2的宽度确实比text1大，这与程序运行结果一样。 那么通过上面的示例，你是不是觉得weight越大占用的空间就越大呢？ 当然不是。如果我们把text1和text2都设置成match_parent 那会怎样呢 :12345678910111213141516171819&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:background="#FF0000" android:text="text1" /&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="2" android:background="#00FF00" android:text="text2" /&gt;&lt;/LinearLayout&gt; 结果显示text1的宽度比text2的还大，但是明明text1 的weight比text2的weight小阿，其实这和上面的计算方式一样的，一开始text1和text2都是match_parent，所以各占用1080px，那剩余空间是1080 - 10802 = -1080px ，是个负数。text1的weight是1，所以text1的宽度是 1080 + (-1080)/3 = 720px ，而text2的是weight是2，所以text2的宽度是 1080 + (-1080) 2 / 3 = 360px ，所以text1的宽度比text2的还大。 其实用LinearLayout+ weight可以代替一些RelativeLayout才能做的功能，比如我们要做一个自适应的布局，左右两个按钮，可以根据屏幕的大小适应，左按钮始终最左边，右按钮始终在最右边，像下面这样：这是很常见的需求，这个小布局有多种实现方式 ：第一种，最简单就是用RelativeLayout，设置layout_alignParentLeft=&quot;true&quot;与layout_alignParentRight=&quot;true&quot;就可以了。第二种，也可以用FrameLayout，通过设置layout_gravity属性来实现，比如 :12345678910111213141516171819&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:background="#FF0000" android:layout_gravity="left" android:text="左" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:background="#00FF00" android:layout_gravity="right" android:text="右" /&gt;&lt;/FrameLayout&gt; 上面代码也可以实现让两个控件位居左右并自适应屏幕。那么我们的LinearLayout是否也可以这样呢，在LinearLayout中设置layout_gravity是无效的，因为LinearLayout是线性的布局，必须从左到右或从上到下的顺序，要想位居左右必须有控件占满中间的部分，所以第三种方法就是利用LinearLayout + Space来实现 ：12345678910111213141516171819202122&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:background="#FF0000" android:text="左" /&gt; &lt;Space android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="1" /&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:background="#00FF00" android:text="右" /&gt;&lt;/LinearLayout&gt; 这代码巧妙的地方是利用Space设置weight为1来占满剩余空间，从而实现效果。 2、weightSum 属性weightSum属性与weight属性有很大关系，通过weightSum控制weight的最大占比。比如我们这样设置 :123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:weightSum="3" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:background="#FF0000" android:text="text1" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="1" android:background="#00FF00" android:text="text2" /&gt;&lt;/LinearLayout&gt; text1与text2本来是一样的weight，可是结果它们都没有撑满屏幕。因为weightSum=&quot;3&quot;，也就是说text1、text2占用的宽度是 120 + 840 / 3 = 400px ,右边还有剩余280px。如果text1与text2的weight超过了weightSum会怎样，我们设置如下看看效果 :1234567891011121314151617181920&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:weightSum="3" android:orientation="horizontal"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="2" android:background="#FF0000" android:text="text1" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:layout_weight="2" android:background="#00FF00" android:text="text2" /&gt;&lt;/LinearLayout&gt; 结果发现text2的文字快到屏幕外了，说明text2的宽度超出了屏幕。其实计算方式还是一样的，它们各占剩余空间的 2/3。我们上面说过text1与text2的宽度都是120px，剩余840，那么此时text1的宽度为 120 + 840 * 2 / 3 = 680px ，两个都是 680px，那text2当然被挤到屏幕外去了。weightSum属性可以用来控制weight属性占用剩余空间的比例。比如我们要做一个布局，一个按钮居中，它宽度是屏幕的一半，还要自适应屏幕，效果如下：你怎么做？ 难道我们要在代码上通过获取屏幕宽度动态设置按钮的宽度吗？还是在xml布局上写死宽度，但是这样要在每个分辨率都适配一个宽度值 … No，No，No，这些方法都很low逼。我们可以利用weightSum属性，代码如下：123456789101112&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:gravity="center" android:orientation="horizontal" android:weightSum="2"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_weight="1" android:text="按钮" /&gt;&lt;/LinearLayout&gt; 运行代码看到按钮半宽居中，自适应所有分辨率的屏幕，符合要求。注意LinearLayout中设置的android:gravity=&quot;center&quot;，它让子View居中放置。 3、divider 、showDividers 属性以往我在设置分割线时，都是新增一个View，用来显示分割线，直到我发现在LinearLayout中添加分割线的新方法。LinearLayout显示分割线主要涉及divider 、showDividers 属性 ： android:divider用于设置分割线的样式，可以是xml的drawable也可以是图片。android:showDividers = &quot;middle|end|beginning|none&quot; 其每个选项的作用： middle 在每一项中间添加分割线 end 在整体的最后一项添加分割线 beginning 在整体的最上方添加分割线 none 不显示分割线 我们先创建一个custom.xml的drawable ，注意设置了宽高，不然是显示不出来的：12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;solid android:color="@android:color/holo_red_light" /&gt; &lt;size android:height="12dp" android:width="2dp"/&gt;&lt;/shape&gt; 设置成android:showDividers = “beginning”时：设置成android:showDividers = “end”时：设置成android:showDividers = “middle”时：还可以组合设置 ，android:showDividers=”beginning|end|middle” ，显示结果： 最后如果大家发现了什么的重要的属性或巧妙的用法，也可以一起交流哈。 参考 在 LinearLayout 添加分割线 divider Layout_weight 完全解析]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)使用注解改进代码检查]]></title>
    <url>%2F2017%2F04%2F22%2F%E8%BD%AC-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%94%B9%E8%BF%9B%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[使用代码检查工具（例如 Lint）可以帮助您找到问题并改进代码，不过，检查工具只能推断这么多信息。例如，Android 资源 ID 使用 int 标识字符串、图形、颜色和其他资源类型，因此，检查工具无法告诉您何时指定字符串资源以及应在什么地方指定颜色。在这种情况下，您的应用可能无法正确渲染或根本无法运行，即使使用代码检查也是如此。您可以使用注解向 Lint 之类的代码检查工具提供提示，帮助检测这些更细微的代码问题。您可以将注解作为元数据标记附加至变量、参数和返回值，用于检查方法返回值、传递的参数以及本地变量和字段。如果与代码检查工具搭配使用，注解可以帮助您检测问题，例如 null 指针异常和资源类型冲突。Android 通过注解支持库支持各种注解。您可以通过 android.support.annotation 软件包获取该库。 向您的项目添加注解要在您的项目中启用注解，请向您的库或应用添加 support-annotations 依赖项。添加的任何注解都会在您随后运行代码检查或 lint任务时进行检查。 添加支持注解库依赖项支持注解库是 Android 支持库的一部分。要向您的项目添加注解，您必须下载支持存储库并向 build.gradle 文件中添加 support-annotations 依赖项。 打开 SDK 管理器，方法是点击工具栏中的 SDK Manager 图标 或者选择 Tools &gt; Android &gt; SDK Manager。 点击 SDK Tools 标签。 展开 Support Repository 并选中 Android Support Repository 复选框。 点击 OK。 继续安装向导的说明操作，安装软件包。 将以下代码行添加到 build.gradle 文件的 dependencies 块中，向您的项目添加 support-annotations 依赖项： 1dependencies &#123; compile com.android.support:support-annotations:24.2.0' &#125; 您下载的库版本可能较高，因此，确保您在此指定的值与第 3 步中的版本匹配。 在显示的工具栏或同步通知中，点击 Sync Now。 如果您在自己的库模块中使用注解，注解将作为 Android 归档 (AAR) 工件的一部分以 XML 格式添加到 annotations.zip 文件中。添加 support-annotations 依赖项不会为您的库的任何下游用户引入依赖关系。如果想要在未使用适用于 Gradle 的 Android 插件但使用 Gradle Java 插件的 Gradle 模块中使用注解（com.android.application 或 com.android.library），您必须明确添加 SDK 存储库，因为无法从 JCenter Java 存储库获得 Android 支持库：1repositories &#123; jcenter() maven &#123; url '&lt;your-SDK-path&gt;/extras/android/m2repository' &#125;&#125; 注：如果您使用 appcompat 库，则无需添加 support-annotations 依赖项。因为 appcompat 库已经依赖注解库，您可以访问相关注解。要查看支持存储库中包含的完整注解列表，请查看支持注解库参考，或者使用自动填充功能显示 import android.support.annotation. 语句的可用选项。 运行代码检查要从 Android Studio 启动代码检查（包含验证注解和自动 Lint 检查），请从菜单栏中选择 Analyze &gt; Inspect Code。Android Studio 将显示冲突消息，在您的代码与注解冲突的地方标记潜在问题并建议可能的解决方法。您还可以通过使用命令行运行 lint 任务来强制注解。尽管这对标记持续集成服务器遇到的问题可能有用，请注意，lint 任务并不会强制 nullness 注解（只有 Android Studio 会强制）。如需了解有关启用和运行 Lint 检查的详细信息，请参阅使用 Lint 改进您的代码。请注意，尽管注解冲突会生成警告，但这些警告不会阻止您的应用编译。 Nullness 注解添加 @Nullable 和 @NonNull 注解，以检查给定变量、参数或返回值的 nullness。@Nullable 注解指示可以为 null 的变量、参数或返回值，而 @NonNull 则指示不可为 null 的变量、参数或返回值。例如，如果一个包含 null 值的局部变量作为已附加 @NonNull 注解的参数传递到某个方法，则构建代码将生成一个指示非 null 冲突的警告。另一方面，对于通过 @Nullable 标记的方法的结果，如果不先检查其是否为 null，那么在尝试引用它时将生成 nullness 警告。只有在每次使用方法时都应明确检查是否为 null 的情况下，才应对方法返回值使用 @Nullable 。下面的示例会将 @NonNull 注解附加到 context 与 attrs 参数，以检查传递的参数值是否不为 null。它还会检查 onCreateView() 方法本身是否不会返回 null：123456789import android.support.annotation.NonNull;/** Add support for inflating the &lt;fragment&gt; tag. **/ @NonNull @Override public View onCreateView(String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; ... &#125; Nullability 分析Android Studio 支持通过运行 nullability 分析，在您的代码中自动推断和插入 nullness 注解。Nullability 分析会在您代码的整个方法层次结构中扫描协定类，以检测： 可返回 Null 的调用方法 不会返回 Null 的方法 可以为 Null 的变量，如字段、局部变量和参数 不能为 Null 值的变量，如字段、局部变量和参数 然后，此分析将自动在已检测到的位置插入相应的 null 注解。要在 Android Studio 中运行 nullability 分析，请选择 Analyze &gt; Infer Nullity。Android Studio 会在代码中已检测到的位置插入 Android @Nullable 和 @NonNull 注解。运行 null 分析后，最好验证一下插入的这些注解。 注：添加 nullness 注解时，自动填充可能会建议 IntelliJ @Nullable 和 @NotNull 注解而不是 Android null 注解，并且可能会自动导入相应的库。不过，Android Studio Lint 检查器仅会查找 Android null 注解。验证您的注解时，请确认您的项目使用 Android null 注解，以便 Lint 检查器可以在代码检查期间正确通知您。 资源注解验证资源类型可能非常有用，因为 Android 对资源（例如可绘制对象和字符串资源）的引用以整型形式传递。需要参数来引用特定类型资源（例如可绘制对象）的代码可以作为预计的引用类型 int 传入，不过实际将引用不同类型的资源，例如 R.string 资源。例如，添加 @StringRes 注解，以检查资源参数是否包含 R.string 引用，如下面所示：1public abstract void setTitle(@StringRes int resId) &#123; … &#125; 在代码检查期间，如果参数中未传入 R.string 引用，注解将生成警告。其他资源类型的注解（例如 @DrawableRes、@DimenRes、@ColorRes 和 @InterpolatorRes）可以使用相同的注解格式添加并在代码检查期间运行。如果您的参数支持多种资源类型，您可以在给定参数上添加更多注解。使用 @AnyRes 能够指示注解的参数可为任意类型的 R 资源。尽管您可以使用 @ColorRes 指定某个参数应为颜色资源，但是颜色整型（RRGGBB 或 AARRGGBB 格式）无法识别为颜色资源。请改用 @ColorInt 注解指示某个参数必须为颜色整型。构建工具会标记不正确代码，该代码会将颜色资源 ID（例如 android.R.color.black）而不是颜色整型传递到已注解方法。 线程注解线程注解可以检查某个方法是否从特定类型的线程调用。支持以下线程注解： @MainThread @UiThread @WorkerThread @BinderThread @AnyThread 注：构建工具会将 @MainThread 和 @UiThread 注解视为可互换，因此，您可以从 @MainThread 方法调用 @UiThread 方法，反之亦然。不过，如果系统应用在不同线程上带有多个视图，UI 线程可与主线程不同。因此，您应使用 @UiThread 标注与应用的视图层次结构关联的方法，使用 @MainThread 仅标注与应用生命周期关联的方法。 如果某个类中的所有方法具有相同的线程要求，您可以向该类添加一个线程注解，以验证该类中的所有方法是否均从相同类型的线程调用。线程注解的一个常见用途是验证 AsyncTask 类中的方法替换，因为此类会执行后台操作并将结果仅发布到 UI 线程上。 值约束注解使用 @IntRange、@FloatRange 和 @Size 注解可以验证传递的参数的值。在应用到用户可能弄错其范围的参数时，@IntRange 和 @FloatRange 都非常有用。@IntRange 注解可以验证整型或长整型参数值是否位于指定范围内。下面的示例可以确保 alpha 参数包含 0 至 255 范围内的整数值：1public void setAlpha(@IntRange(from=0,to=255) int alpha) &#123; … &#125; @FloatRange 注解可以检查浮点或双整型参数值是否位于指定的浮点值范围内。下面的示例可以确保 alpha 参数包含 0.0 至 1.0 的浮点值：1public void setAlpha(@FloatRange(from=0.0, to=1.0) float alpha) &#123;...&#125; @Size 注解可以检查集合或数组的大小，以及字符串的长度。@Size 注解可用于验证以下质量： 最小大小（例如 @Size(min=2)） 最大大小（例如 @Size(max=2)） 确切大小（例如 @Size(2)） 表示大小必须为此倍数的数字（例如 @Size(multiple=2)） 例如，@Size(min=1) 可以检查某个集合是否不为空，@Size(3) 可以验证某个数组是否刚好包含三个值。下面的示例可以确保 location数组至少包含一个元素：1int[] location = new int[3];button.getLocationOnScreen(@Size(min=1) location); 权限注解使用 @RequiresPermission 注解可以验证方法调用方的权限。要检查有效权限列表中是否存在某个权限，请使用 anyOf 属性。要检查是否存在一组权限，请使用 allOf 属性。下面的示例会标注 setWallpaper() 方法，以确保方法的调用方拥有 permission.SET_WALLPAPERS 权限：12@RequiresPermission(Manifest.permission.SET_WALLPAPER)public abstract void setWallpaper(Bitmap bitmap) throws IOException; 此示例要求 copyFile() 方法的调用方同时具有外部存储空间的读写权限：12@RequiresPermission(allOf = &#123; Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;)public static final void copyFile(String dest, String source) &#123; ...&#125; 对于 intent 权限，请将权限要求添加到定义 intent 操作名称的字符串字段上：12@RequiresPermission(android.Manifest.permission.BLUETOOTH)public static final String ACTION_REQUEST_DISCOVERABLE = "android.bluetooth.adapter.action.REQUEST_DISCOVERABLE"; 对于您需要单独读写权限的内容提供程序的权限，请在 @RequiresPermission.Read 或 @RequiresPermission.Write 注解中包含每个权限要求：123@RequiresPermission.Read(@RequiresPermission(READ_HISTORY_BOOKMARKS))@RequiresPermission.Write(@RequiresPermission(WRITE_HISTORY_BOOKMARKS))public static final Uri BOOKMARKS_URI = Uri.parse("content://browser/bookmarks"); 间接权限如果权限依赖于提供给方法参数的特定值，请对参数本身使用 @RequiresPermission，而不用列出具体权限。例如，startActivity(Intent)) 方法会对传递到方法的 intent 使用间接权限：1public abstract void startActivity(@RequiresPermission Intent intent, @Nullable Bundle) &#123;...&#125; 在您使用间接权限时，构建工具将执行数据流分析以检查传递到方法的参数是否具有任何 @RequiresPermission 注解。随后，它们会对方法本身强制参数的任何现有注解。在 startActivity(Intent) 示例中，当一个不具有相应权限的 intent 传递到方法时，Intent 类中的注解会针对 startActivity(Intent) 的无效使用生成警告，如图 1 中所示。图 1. startActivity(Intent) 方法上从间接权限注解生成的警告。构建工具会在 startActivity(Intent) 上从 Intent 类中相应 intent 操作名称的注解生成警告：123@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)@RequiresPermission(Manifest.permission.CALL_PHONE)public static final String ACTION_CALL = "android.intent.action.CALL"; 如果需要，在标注方法的参数时，您可以将 @RequiresPermission 替换为 @RequiresPermission.Read 和/或 @RequiresPermission.Write。不过，间接权限 @RequiresPermission 不应与读取或写入权限注解搭配使用。 返回值注解使用 @CheckResult 注解可以验证实际使用的是方法的结果还是返回值。添加注释来阐明可能令人困惑的方法的结果，而不是使用 @CheckResult 标注每个非空方法。例如，新 Java 开发者经常误认为 &lt;String&gt;.trim() 会移除原始字符串中的空格。使用 @CheckResult标注方法会在调用方未对方法返回值作任何处理的地方标记 &lt;String&gt;.trim()的使用。下面的示例会标注 checkPermissions()) 方法，以确保实际引用方法的返回值。它还会将 enforcePermission() 方法指定为要向开发者建议的替换方法：12@CheckResult(suggest="#enforcePermission(String,int,int,String)")public abstract int checkPermission(@NonNull String permission, int pid, int uid); CallSuper 注解使用 @CallSuper 注解可以验证替换方法是否会调用方法的超类实现。下面的示例会标注 onCreate() 方法，以确保任何替换方法实现都会调用 super.onCreate() ：1@CallSuperprotected void onCreate(Bundle savedInstanceState) &#123;&#125; Typedef 注解使用 @IntDef 和 @StringDef 注解，以便能够创建整型和字符串集的枚举注解来验证其他类型的代码引用。Typedef 注解可以确保特定参数、返回值或字段引用特定的常量集。它们还可以完成代码以自动提供允许的常量。Typedef 注解使用 @interface声明新的枚举注解类型。@IntDef 和 @StringDef 注解以及 @Retention 可以标注新注解，并且为定义枚举的类型所必需。@Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中。下面的示例说明了创建注解的具体步骤，此注解可以确保作为方法参数传递的值引用一个定义的常量：12345678910111213141516import android.support.annotation.IntDef;public abstract class ActionBar &#123; // Define the list of accepted constants and declare the NavigationMode annotation @Retention(RetentionPolicy.SOURCE) @IntDef(&#123;NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS&#125;) public @interface NavigationMode &#123;&#125; // Declare the constants public static final int NAVIGATION_MODE_STANDARD = 0; public static final int NAVIGATION_MODE_LIST = 1; public static final int NAVIGATION_MODE_TABS = 2; // Decorate the target methods with the annotation @NavigationMode public abstract int getNavigationMode(); // Attach the annotation public abstract void setNavigationMode(@NavigationMode int mode); 在您构建此代码时，如果 mode 参数不引用一个定义的常量（NAVIGATION_MODE_STANDARD、NAVIGATION_MODE_LIST 或 NAVIGATION_MODE_TABS），则会生成警告。您还可以组合 @IntDef 和 @IntRange，以指示整型可以是给定的常量集或某个范围内的值。 允许将常量与标志相结合如果用户可以将允许的常量与标志（例如，|、&amp; 和 ^，等等）相结合，则您可以通过 flag 属性定义一个注解，以检查某个参数或返回值是否会引用有效模式。下面的示例将使用一组有效的 DISPLAY_ 常量创建 DisplayOptions 注解：1234567import android.support.annotation.IntDef;...@IntDef(flag=true, value=&#123; DISPLAY_USE_LOGO, DISPLAY_SHOW_HOME, DISPLAY_HOME_AS_UP, DISPLAY_SHOW_TITLE, DISPLAY_SHOW_CUSTOM&#125;)@Retention(RetentionPolicy.SOURCE)public @interface DisplayOptions &#123;&#125;... 在您使用注解标志构建代码时，如果经过修饰的参数或返回值不引用有效模式，则将生成警告。 代码可访问性注解使用 @VisibleForTesting 和 @Keep 注解可以表示方法、类或字段的可访问性。@VisibleForTesting 注解指示一个代码块的可见性是否高于让代码变得可测试所需要的水平。@Keep 注解可以确保如果在构建时缩减代码，标注的元素不会移除。它一般会添加到通过反射访问的方法和类中，以阻止编译器将代码视为未使用。 另请参阅使用 Lint 改进您的代码Android Studio 中的注解]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中容易出错的十五题]]></title>
    <url>%2F2017%2F04%2F16%2FJava%E4%B8%AD%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、下面有关List接口、Set接口和Map接口的描述，错误的是？A、他们都继承自Collection接口B、List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置C、Set是一种不包含重复的元素的CollectionD、Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value 答案：A。List,Set继承了Collection接口，而Map是一个单独的接口。 2、[不定项选择题] ArrayLists和LinkedList的区别，下述说法正确的有？A、ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。B、对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。C、对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。D、ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。 答案：A B C D。不解释。 3、[不定项选择题] 关于volatile关键字，下列描述不正确的是？A、用volatile修饰的变量，每次更新对其他线程都是立即可见的。B、对volatile变量的操作是原子性的。C、对volatile变量的操作不会造成阻塞。D、不依赖其他锁机制，多线程环境下的计数器可用volatile实现。 答案：BD 。所谓volatile的措施，就是 每次从内存中取值，不从缓存中拿值。这就保证了用volatile修饰的共享变量，每次的更新对于其他线程都是可见的。 volatile保证了其他线程的立即可见性，就没有保证原子性。 由于有些时候对volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。 4、[不定项选择题] 下面有关java threadlocal说法正确的有？A、ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递B、线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收C、在Thread类中有一个Map，用于存储每一个线程的变量的副本。D、对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式 答案：A B C D。ThreadLocal类用于创建一个线程本地变量。线程内共享，线程间独立。在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。 5、关于sleep()和wait()，以下描述错误的一项是（ ）A、sleep是线程类（Thread）的方法，wait是Object类的方法；B、sleep不释放对象锁，wait放弃对象锁C、sleep暂停线程、但监控状态仍然保持，结束后会自动恢复D、wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态 答案：D，notity()和notifyAll()两个方法均可，应该进入就绪状态而不是运行状态。 6、有如下4条语句：()Integer i01=59;int i02=59;Integer i03=Integer.valueOf(59);Integer i04=new Integer(59); 以下输出结果为false的是:A、System.out.println(i01==i02);B、System.out.println(i01==i03);C、System.out.println(i03==i04);D、System.out.println(i02==i04); 答案：C。Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127并且大于等于-128时才可使用常量池，因为他们至占用一个字节(-128~127); i02 == i04时，i04自动拆箱，调用Integer的intValue()方法，返回是一个int类型。所以如果你测试如下代码 :1234567891011public static void main(String[] args) &#123; Integer a = 127; Integer b = 127; Integer c = 128; Integer d = 128; System.out.println(a == b); System.out.println(c == d);&#125; 结合自动封装、常量池以及Integer.valueOf方法就不难得出，答案时true和false； 7、假定str0,…,str4后序代码都是只读引用。Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）123456static String str0="0123456789";static String str1="0123456789";String str2=str1.substring(5);String str3=new String(str2);String str4=new String(str3.toCharArray());str0=null; A、5B、10C、15D、20 答案：C。substring实际是new，5字符；str3和4也都是new，每个5字符，分别都会创建新的对象；常量池是PermGen的。因此应该是一共15字符。Java堆区分为三个区：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）,年轻代由一个Eden区和俩个survivor区组成,新创建的对象都在年轻代的Eden区，经过一次JC收集后，存活下来的会被复制到survivor区(一个满了，就全部移动到另外一个大的中，但要保证其中一个survivor为空)，经过多次JC后，还存活的对象就被移到老年代了。 持久代就是经常说的方法区里面存放类信息，常量池。如下图所示： 8、以下哪些jvm的垃圾回收方式采用的是复制算法回收A、新生代串行收集器B、老年代串行收集器C、并行收集器D、新生代并行回收收集器E、老年代并行回收收集器F、cms收集器 答案：A D 。几种最基本的java回收算法： 标记-清除法：标记所有从根结点开始的可达对象，缺点是会造成内存空间不连续，不连续的内存空间的工作效率低于连续的内存空间，不容易分配内存。 复制算法：将内存空间分成两块，每次将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块。算法效率高，但是代价是系统内存折半。适用于新生代(存活对象少，垃圾对象多)。 标记－压缩算法：标记－清除的改进，清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清理边界所有空间既避免碎片产生，又不需要两块同样大小的内存快，性价比高。适用于老年代。 9、[不定项选择题] 下面有关java类加载器，说法正确的是？A、引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的B、扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。C、系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类D、tomcat为每个App创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用 答案：ABCD。JVM三种预定义类型类加载器,详见这篇文章: 启动（Bootstrap）类加载器：引导类装入器是用本地代码实现的类装入器，它负责将 /lib 下面的类库加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 标准扩展（Extension）类加载器：扩展类加载器是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader） 实现的。它负责将 &lt; Java_Runtime_Home &gt;/lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 系统（System）类加载器：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。 10、以下代码的输出结果是？12345678910111213141516public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println("构造块"); &#125; static &#123; System.out.println("静态块"); &#125; public static void main(String[] args) &#123; B t = new B(); &#125;&#125; A、静态块 构造块 构造块 构造块B、构造块 静态块 构造块 构造块C、构造块 构造块 静态块 构造块D、构造块 构造块 构造块 静态块 答案：C 。注意点 ： 每调用一次构造方法，则执行一次构造块；静态块只在类加载的时候加载一次；有多个静态变量或块时，按声明顺序加载。 11、有关下述Java代码描述正确的选项是__。12345678public class TestClass &#123; private static void testMethod()&#123; System.out.println("testMethod"); &#125; public static void main(String[] args) &#123; ((TestClass)null).testMethod(); &#125;&#125; A、编译不通过B、编译通过，运行异常，报NullPointerExceptionC、编译通过，运行异常，报IllegalArgumentExceptionD、编译通过，运行异常，报NoSuchMethodExceptionE、编译通过，运行异常，报ExceptionF、运行正常，输出testMethod 答案：F 。方法是static静态方法，直接使用”类.方法”即可，因为静态方法使用不依赖对象是否被创建。null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。 12、下面关于abstract关键字描述错误的是（）A、abstract关键字可以修饰类或方法B、final类的方法都不能是abstract，因为final类不能有子类C、abstract类不能实例化D、abstract类的子类必须实现其超类的所有abstract方法 答案：D 。抽象类不能被实例化，无法使用new关键字调用抽象类的构造器创建抽象类的实例，即使抽象类不包含抽象方法，也不能被实例化。 13、如下代码，执行test()函数后，屏幕打印结果为（）12345678910111213141516public class Test2&#123; public void add(Byte b) &#123; b = b++; &#125; public void test() &#123; Byte a = 127; Byte b = 127; add(++a); System.out.print(a + " "); add(b); System.out.print(b + ""); &#125;&#125; A、127 127B、128 127C、129 128D、以上都不对 答案：D 。Byte的首字母为大写，是类，看似是引用传递，但是在add函数内实现++操作，会自动拆包成byte值传递类型，所以add函数还是不能实现自增功能。也就是说add函数只是个摆设，没有任何作用。 Byte类型值大小为-128~127之间。 add(++a);这里++a会越界，a的值变为-128 add(b); 前面说了，add不起任何作用，b还是127。 14、问这个程序的输出结果。1234567891011121314151617181920212223242526272829package Wangyi;class Base&#123; public void method() &#123; System.out.println("Base"); &#125; &#125;class Son extends Base&#123; public void method() &#123; System.out.println("Son"); &#125; public void methodB() &#123; System.out.println("SonB"); &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Base base = new Son(); base.method(); base.methodB(); &#125;&#125; A、Base SonBB、Son SonBC、Base Son SonBD、编译不通过 答案：D 。这句new 了一个派生类，赋值给基类，所以编译器认为base对象就是Base类型的Base类中不存在methodB()方法，所以编译不通过。 15、检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。1234567891011121314package algorithms.com.guan.javajicu; public class Inc &#123; public static void main(String[] args) &#123; Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); &#125; public void fermin(int i) &#123; i++; &#125; &#125; A、0B、1C、2D、3 答案：A 。顺序应该是：先计算表达式的值，得0，然后i加1，此时i=1，最后赋值，赋值是把表达式的值赋值，所以，i又变成0了。Java使用了中间缓存变量机制：123456789i=i++;等同于：temp=i；(等号右边的i)i=i+1; (等号右边的i)i=temp; (等号左边的i)而i=++i;则等同于：i=i+1;temp=i;i=temp;]]></content>
      <categories>
        <category>程序基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发中容易忽略的类、方法、接口]]></title>
    <url>%2F2017%2F03%2F29%2FAndroid%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[UI相关 android:drawableLeft、android:drawableTop、android:drawableRight、android:drawableBottom 可以设置显示图片的位置，一般我们需要一个LinearLayout + ImageView + TextView 才能实现的效果 ，TextView用这属性就能实现了。还可以用TextView.setTextView.setCompoundDrawablePadding代码设置TextView的各个位置的drawable padding。 TextView.setError() 在验证用户输入的时候很棒。 TextView.append()) 很有用的方法，用于为TextView添加显示内容。 Space Space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。 ViewStub 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。 Merge 此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。 android:clipChildren 和 android:clipToPadding clipToPadding就是说控件的绘制区域是否在padding里面的，true的情况下如果你设置了padding那么绘制的区域就往里 缩，clipChildren是指子控件是否超过padding区域，这两个属性默认是true的，所以在设置了padding情况下，默认滚动是在 padding内部的，要达到上面的效果主要把这两个属性设置了false那么这样子控件就能画到padding的区域了。使用场景如：ActionBar（透明）下显示Listview而第一项要在actionbar下。参见 android:clipToPadding和android:clipChildren。 android:weightSum (LinearLayout) 如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。 android:duplicateParentState (View) 此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。常见的使用场景是某些时候一个按钮很小，我们想要扩大其点击区域的时候通常会再给其包裹一层布局，将点击事件写到Parent上，这时候如果希望被包裹按钮的点击效果对应的Selector继续生效的话，这时候duplicateParentState就派上用场了。 android:fillViewport (ScrollView) 在这片文章中有详细介绍文章链接，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。 android:tileMode (BitmapDrawable) 可以指定图片使用重复填充的模式。 android:enterFadeDuration/android:exitFadeDuration (Drawables) 此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。 视图操作相关 AutoScrollHelper 在可滚动视图中长按边缘实现滚动，Android View.OnTouchListener 的子类。 ViewDragHelper ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，DrawerLayout就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的优秀文章。 ViewParent.requestDisallowInterceptTouchEvent() Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权。 View.generateViewId() 每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。 View类中的三个方法：callOnClick()，performClick()，performLongClick()，用于触发View的点击事件。 TouchSlop 系统所能识别出的被认为是最小的滑动距离，ViewConfiguration.get(context).getScaledTouchSlop()。 VelocityTracker 可用于 View 滑动事件速度跟踪。 系统相关 ActivityManager.getMemoryClass() 告诉你你的机器还有多少内存，在计算缓存大小的时候会比较有用。 ActivityManager.clearApplicationUserData() 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。 Activity.recreate () 强制让 Activity 重建。 Activity.onBackPressed() 很方便的管理back键的方法，有时候需要自己控制返回键的事件的时候，可以重写一下。比如加入 “点两下back键退出” 功能。 Context.getCacheDir() 获取缓存数据文件夹的路径，这个路径通常在SD卡上/data/您的应用程序包名/cache/ 下面。测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空。 Context.getExternalFilesDir() 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。 Environment.getExternalStoragePublicDirectory() 还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。 ActivityLifecycleCallbacks 接口，用于在Application类中监听各Activity的状态变化。 RemoteCallbackList列表 ,在Service中可以监听client的进程是否退出，并自动删除。 Context.createConfigurationContext() 自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。 PackageManager.checkSignatures () 如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。 Fragment 的 setUserVisibleHint 方法，可实现 fragment 对用户可见时才加载资源（延迟加载）, 在ViewPager中切换时特别有用。 DialogFragment.setShowsDialog() 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。 FragmentManager.enableDebugLogging () 在需要观察 Fragment 状态的时候会有帮助。 LocalBroadcastManager 这个会比全局的 broadcast 更加安全，简单，快速。像 otto 这样的 Event buses 机制对你的应用场景更加有用。 -nodpi 在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。 Resources类中的getIdentifier(name, defType, defPackage)方法，根据资源名称获取其ID，做UI时经常用到。 工具类 TextUtils.isEmpty() 简单的工具类,用于检测是否为空。 DatabaseUtils 一个包含各种数据库操作的使用工具。 ThumbnailUtils 帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。 DateUtils.formatDateTime() 用来进行区域格式化工作，输出格式化和本地化的时间或者日期。 PhoneNumberUtils.formatNumber () 顾名思义，这是对数字进行格式化操作的时候用的。 Linkify.addLinks() 在Text上添加链接。很实用。 UrlQuerySanitizer 使用这个工具可以方便对 URL 进行检查。 Formatter.formatFileSize() 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB，G，KB之类的字符串。 集合类 ArrayMap，比 HashMap 更高的内存效率，但比 HashMap 慢，不适合有大量数据的场景。 SparseArray Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。 Arrays类中的一系列关于数组操作的工具方法：binarySearch()，asList()，equals()，sort()，toString()，copyOfRange()等； Collections类中的一系列关于集合操作的工具方法：sort()，reverse()等； 常量类 Build.VERSION_CODES 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性。 Build.PRODUCT 可以获取手机的项目名 BuildConfig 这个类声明了 DEBUG模式、包名、BUILD_TYPE、FLAVOR、VERSION_CODE、VERSION_NAME 等，在代码中可以直接使用，不用去检测apk信息。 参考 Android开发中，有哪些让你觉得相见恨晚的方法、类或接口？ Android Tips Round-Up, Part 1 Android Tips Round-Up, Part 2 Android Tips Round-Up, Part 3 Android Tips Round-Up, Part 4 Android Tips Round-Up, Part 5]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Kotlin实现的三种 RxBus]]></title>
    <url>%2F2017%2F03%2F22%2F%E5%9F%BA%E4%BA%8EKotlin%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E7%A7%8D-RxBus%2F</url>
    <content type="text"><![CDATA[RxBus 是 EventBus 在RxJava 的替代品 ，而在RxJava 中只需要短短几行代码就能实现。RxJava1 与 RxJava2 有些微不同，具体可以参考 What’s different in 2.0 。下面总结用Kotlin 实现的不同场景的 RxBus : 没有背压处理（Backpressure）的 Rxbus 有背压处理的 RxBus 有异常处理的 Rxbus （订阅者处理事件出现异常也能继续收到事件） 没有背压处理（Backpressure）的 Rxbus在RxJava2里，引入了Flowable这个类来处理Backpressure，而Observable不包含Backpressure 处理。123456789101112131415object RxBus &#123; private val mBus: Subject&lt;Any&gt; = PublishSubject.create() fun &lt;T&gt; toObservable(clzz: Class&lt;T&gt;): Observable&lt;T&gt; = mBus.ofType(clzz) fun toObservable(): Observable&lt;Any&gt; = mBus fun post(obj: Any) &#123; mBus.onNext(obj) &#125; fun hasObservers(): Boolean &#123; return mBus.hasObservers() &#125;&#125; 但是在调用toObservable(clzz: Class&lt;T&gt;)的时候，不要简单使用 XXX.class ，因为这样不符合Kotlin的语法，正确的的调用方式是 :1RxBus.toObservable(String::class.java).subscribe( ... ) 有背压处理的 RxBus12345678910111213141516171819object RxBus &#123; private val mBus: FlowableProcessor&lt;Any&gt; = PublishProcessor.create() fun &lt;T&gt; toFlowable(tClass: Class&lt;T&gt;): Flowable&lt;T&gt; &#123; return mBus.ofType(tClass) &#125; fun toFlowable(): Flowable&lt;Any&gt; &#123; return mBus &#125; fun post(obj: Any) &#123; mBus.onNext(obj) &#125; fun hasSubscribers(): Boolean &#123; return mBus.hasSubscribers() &#125;&#125; 有异常处理的 Rxbus -基于 RxRelay RxRelay 是既是Observable也是Consumer的RxJava 类型。123456789101112131415object RxBus3 &#123; private val mBus: PublishRelay&lt;Any&gt; = PublishRelay.create() fun &lt;T&gt; toObservable(clzz: Class&lt;T&gt;): Observable&lt;T&gt; = mBus.ofType(clzz) fun toObservable(): Observable&lt;Any&gt; = mBus fun post(obj: Any) &#123; mBus.accept(obj) &#125; fun hasObservers(): Boolean &#123; return mBus.hasObservers() &#125;&#125; 关于RxRelay与Subject 的区别，网上一般说”RxRelay 即使出现异常也不会终止订阅关系” , 一开始看到这句话，有点蒙，因为根据我的实际验证，订阅者有异常时，这个订阅会自动取消，也不会影响其它订阅者，这个效果 RxRelay 与 Subject 是一样的。而它们真正的区别是 Subject 是Observable也是Observer，所以它可以发送 onComplete 、onError ,这样，会取消订阅所有的订阅者，订阅有被动取消订阅的意思。 RxRelay 是Observable也是Consumer , 所以RxRelay 不能发送 onComplete 、onError , 那也就不用担心被中断了。 参考 RxJava 2 版本的 Rxbus 基于 RxJava 2 和 RxRelay 实现 RxBus]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 使用Kotlin的一些技巧]]></title>
    <url>%2F2017%2F03%2F02%2FAndroid-%E4%BD%BF%E7%94%A8Kotlin%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[打印Log 1Log.d(TAG , "print i = $i , j = $j , len = $&#123;str.length&#125; ") 设置 listeners 1myButton.setOnClickListener &#123; navigateToDetail() &#125; for 语句中的范围在Java 中 ： 1234567for (int i = 1; i &lt;= 10 ; i++) &#123; &#125;for (int i = 1; i &lt; 10 ; i++) &#123; &#125;for (int i = 10; i &gt;= 0 ; i--) &#123; &#125;for (int i = 1; i &lt;= 10 ; i+=2) &#123; &#125;for (int i = 10; i &gt;= 0 ; i-=2) &#123; &#125;for (String item : collection) &#123; &#125;for (Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123; &#125; 在Kotlin 中 ：1234567for (i in 1..10) &#123; &#125;for (i in 1 until 10) &#123; &#125;for (i in 10 downTo 0) &#123; &#125;for (i in 1..10 step 2) &#123; &#125;for (i in 10 downTo 1 step 2) &#123; &#125;for (item in collection) &#123; &#125;for ((key, value) in map) &#123; &#125; 参数个数不定的函数在Java 中我们可以定义参数个数不固定的函数 :1void doSomething(int... numbers) &#123; &#125; 而在Kotlin中我们要用 vararg 关键字 ， 使用上是一样的 ：1fun doSomething(vararg numbers: Int) &#123; &#125; Handler、Thread可以写得更简洁 1234view.postDelayed(&#123; doWhatever() &#125;, 200)Thread().run &#123; // Running in a thread &#125; 省去一些不必要的代码一般在java中我们经常要判断一个类对象是否为空，而在kotlin 中，对象一般是非空的，除非你定义时加了?号，这样在代码中就不必要经常加空判断了。 12val str : String = null //报错val str : String? = null //正常 而kotlin对空的判断也很简洁 :12val nullStr : String? = nullval size : Int = nullStr?.length ?: 0 // 如果nullStr为空就返回0 解析布局我们以前用java在inflate一个布局时，一般是这样写的 :1LayoutInflater.from(parent.getContext()).inflate(R.id.my_layout, parent, false); 在Kotlin中，我们可以定义扩展函数 ：123fun ViewGroup.inflate(@LayoutRes layoutRes: Int, attachToRoot: Boolean = false): View &#123; return LayoutInflater.from(context).inflate(layoutRes, this, attachToRoot)&#125; 这样在代码中我们就可以这样使用它 ：12parent.inflate(R.layout.my_layout)parent.inflate(R.layout.my_layout, true) ImageView 加载网络图片我们仍然为ImageView 定义一个扩展函数，使用你的加载图片的库，比如Picasso：123fun ImageView.loadUrl(url: String) &#123; Picasso.with(context).load(url).into(this)&#125; 这样在代码中我们就可以这样使用它 ：1imageView.loadUrl("http://..../") 处理Options Menu在Java时，在处理多个选择时我们一般用 switch，而在Kotlin中，我们可以用when 语句 ：1234567override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) &#123; R.id.action_settings -&gt; consume &#123; navigateToSettings() &#125; R.id.nav_camera -&gt; drawer.consume &#123; navigateToCamera() &#125; R.id.nav_gallery -&gt; drawer.consume &#123; loadGallery() &#125; R.id.nav_slideshow -&gt; drawer.consume &#123; loadSlideshow() &#125; else -&gt; super.onOptionsItemSelected(item)&#125; 其中consume 函数是一个 inline 函数 ：1234inline fun consume(f: () -&gt; Unit): Boolean &#123; f() return true&#125; 初始化控件在Java时，我们一般要在setContentView之后再调用findViewByID初始化控件，而在Kotlin中可以用lazy懒加载 ： 12345678override val textView by lazy &#123; findViewById(R.id.sample_text) as TextView &#125;override val dataBase by lazy &#123; DataBase(this) &#125;override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_detail) textView.setText(R.string.text) dataBase.loadWhatever()&#125; 处理集合类Kotlin中的集合类提供了很多处理函数，方便我们调用，比如 filter、sort、map. 1234return parsedContacts.filter &#123; it.name != null &amp;&amp; it.image != null &#125; .sortedBy &#123; it.name &#125; .map &#123; Contact(it.id, it.name!!, it.image!!) ]&#125; 定义 数据类一般在Java定义数据类时，getters, setters, toString(), equals() … 都需要我们自己编写，在Kotlin就不用这么麻烦了。 1data class Person(val name: String, val surname: String, val age: Int) 定义常量 12345678910object DefaultValues &#123; val FILES_TO_DOWNLOAD = 100&#125;class DefaultValues private constructor() &#123; companion object &#123; val FILES_TO_DOWNLOAD = 100 &#125;&#125;// 只能在 top levelconst val DEFAULT_FILES_TO_DOWNLOAD = 100 定义单例 12345678910class Singleton private constructor() &#123; private object Holder &#123; val INSTANCE = Singleton() &#125; companion object &#123; val instance: Singleton by lazy &#123; Holder.INSTANCE &#125; &#125;&#125; 参考Kotlin awesome tricks for Androidkotlin vs java]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 RxJava2 backpressure的一些理解]]></title>
    <url>%2F2017%2F02%2F18%2F%E5%85%B3%E4%BA%8E-RxJava2-backpressure%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[RxJava2 中的背压在RxJava2里，引入了Flowable这个类来处理backpressure，而Observable不包含backpressure处理。Flowable的三种Backpressure策略： BackpressureStrategy.BUFFERonBackpressureBuffer是不丢弃数据的处理方式。把上游收到的全部缓存下来，等下游来请求再发给下游。相当于一个水库。但上游太快，水库（buffer）就会溢出。 BackpressureStrategy.DROP 与 BackpressureStrategy.LATESTDrop 和Latest 类似，都会丢弃数据，下游通过request请求产生令牌给上游，上游接收到多少令牌，就发送多少，当令牌为0的时候，上游开始丢弃数据。区别在于，drop直接丢弃数据不缓存数据。而latest缓存最新的一条数据，当上游收到令牌，就把缓存的上一条“最新”数据发送给下游。 例如 ：123456789Flowable&lt;Integer&gt; flowable = Flowable.create((FlowableOnSubscribe&lt;Integer&gt;) e -&gt; &#123; for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; Log.d(TAG, "onNext : " + i); e.onNext(i); Thread.sleep(10); &#125; &#125;, BackpressureStrategy.DROP).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); Flowable以10毫秒一次派发数据，注意我们让Flowable和订阅者运行在不同的线程，这样才能看出生产与消费在不同效率下时的差异性，如果Flowable和订阅者在同一线程，背压是没什么意义的。假设订阅他们的方法都是:12345678910111213141516171819202122Subscription mSubscription;flowable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription subscription) &#123; mSubscription = subscription; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "onNext: " + integer); &#125; @Override public void onError(Throwable throwable) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); 我们在onSubscribe中保存了Subscription ，以后 方便我们可以在任何时候request 数据。我们添加一个按钮，以实现手动request数据 ，代码如下：123if(mSubscription != null) &#123; mSubscription.request(64);&#125; 我们一开始request 64个数据，我们启动Flowable后，隔一段时间才点击request , log打印 0 ~ 63 ：123456D/SimpleExampleActivity: onNext: 0D/SimpleExampleActivity: onNext: 1D/SimpleExampleActivity: onNext: 2...D/SimpleExampleActivity: onNext: 63D/SimpleExampleActivity: onNext: 64 隔一段时间第二次点击request , log打印 64~ 127 ：123456D/SimpleExampleActivity: onNext: 64D/SimpleExampleActivity: onNext: 65D/SimpleExampleActivity: onNext: 66...D/SimpleExampleActivity: onNext: 126D/SimpleExampleActivity: onNext: 127 隔一段时间第三次点击request , log打印 1243~ 1306：1234567D/SimpleExampleActivity: onNext: 1243D/SimpleExampleActivity: onNext: 1244D/SimpleExampleActivity: onNext: 1245...D/SimpleExampleActivity: onNext: 1304D/SimpleExampleActivity: onNext: 1305D/SimpleExampleActivity: onNext: 1306 我们使用是BackpressureStrategy.DROP ， 与就是 直接丢弃数据不缓存数据 。可是我们一开始隔了点时间再request时，还是打印从 0 ~ 127 ， 这说明 Flowable 本身就会存储缓存 128 个数据，超过128个后执行我们的策略，也就是丢弃。所以 1243~ 1306 其实是我们在第二次点击后，重新缓存的128数据。如果我们换成 BackpressureStrategy.BUFFER ， 那么不管你点击多少次，数据都是连续的，因为 BackpressureStrategy.BUFFER 策略会把数据一直放到内存中，直到发生OutOfMemoryError。我们现在修改request 的数目 ，改成 每次 request 96 个 ， 代码如下 ：123if(mSubscription != null) &#123; mSubscription.request(96);&#125; 第一次点击request , log打印 0 ~ 95 , 没什么问题123456D/SimpleExampleActivity: onNext: 0D/SimpleExampleActivity: onNext: 1D/SimpleExampleActivity: onNext: 2...D/SimpleExampleActivity: onNext: 94D/SimpleExampleActivity: onNext: 95 隔一段时间第二次点击request , log打印 96 ~ 127 , 188 ~ 251 :1234567891011D/SimpleExampleActivity: onNext: 96D/SimpleExampleActivity: onNext: 97D/SimpleExampleActivity: onNext: 98...D/SimpleExampleActivity: onNext: 126D/SimpleExampleActivity: onNext: 127D/SimpleExampleActivity: onNext: 188D/SimpleExampleActivity: onNext: 189...D/SimpleExampleActivity: onNext: 250D/SimpleExampleActivity: onNext: 251 隔一段时间第三次点击request , log打印 252 ~ 283 , 650 ~ 713:12345678910D/SimpleExampleActivity: onNext: 252D/SimpleExampleActivity: onNext: 253...D/SimpleExampleActivity: onNext: 282D/SimpleExampleActivity: onNext: 283D/SimpleExampleActivity: onNext: 650D/SimpleExampleActivity: onNext: 651...D/SimpleExampleActivity: onNext: 712D/SimpleExampleActivity: onNext: 713 我们可以看到第二次、第三次时打印的数据出现了中断的情况。我们知道Flowable 默认会缓存 127个数据，那么第一次点击之后应该剩下 128 - 96 = 32个 ， 所以第二次首先打印 96 ~ 127 ， 之后再打印 188 ~ 251 64个数据。第三次又打印了 252 ~ 283 32个数据。第二次打印中断之后打印的 64个数据 加上 第三次打印中断前打印的 32个，刚好是 96个数据，也就是打印中断的时间点的数据刚好是96个。这个96就是Flowable 重新去拉取缓存的限制，这是在源码上设定的，就是说首先缓存了 128个数据之后，被消费了96个数据时才会重新缓存。所以在第二次时，从127后就打印了 188，因为这个188是在第一次点击之后就重新缓存了。 总结Flowable 有三种Backpressure策略，分别是BackpressureStrategy.BUFFER、BackpressureStrategy.DROP 和 BackpressureStrategy.LATEST。默认会缓存 127个数据，被消费了96个数据后才会重新缓存。 参考探索专为 Android 而设计的 RxJava 2RxJava2 vs RxJava1]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Dagger2中的@Singleton的理解]]></title>
    <url>%2F2017%2F01%2F16%2F%E5%85%B3%E4%BA%8EDagger2%E4%B8%AD%E7%9A%84-Singleton%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Dagger被Square开发，项目地址：square.github.io/dagger使用了一段时间的Dagger2之后，对Dagger2有些小小的认识。 使用Dagger依赖注入的好处 增加开发效率、省去重复的简单体力劳动 更好的管理类实例 app中的组件不需要知道有关实例创建和生命周期的任何事情，这些由我们的依赖注入框架管理的。 解耦一个类的创建是非常可能充斥在app的多个类中的，假如该类的构造函数发生变化，那这些涉及到的类都得进行修改。对MVP架构来说，可以进一步降低modle-view-presenter之间的耦合度。 Dagger各模块的联系 @Module用于标记提供依赖的类，Dagger就知道在那里需要构造对象了。@Provides标记Module中返回依赖的方法。 @Inject注解。作为JSR-330标准的一部分，标记那些依赖注入框架提供的依赖。Dagger2中，有3种不同的方式提供依赖： 构造器注入 域注入 方法注入 @Component : 这个注解用于构建接口，该接口把所有封装在一起。这里，我们定义需要依赖的模块(或组件)。这里定义了那些依赖可注入，我们的组件可以注入哪里。@Component是连接@Module和@Inject的桥梁。 利用@Singleton构建单例一般需要创建单例时，我们需要在 Module 和蔼Component 中都添加 @Singleton 注解1234567891011121314@Modulepublic class PersonModule &#123; @Provides @Singleton public Person providePerson() &#123; return new Person(); &#125;&#125;@Singleton@Component(modules = PersonModule.class)public interface MainComponent &#123; void inject(MainActivity activity);&#125; 然后在 Application 类中创建 MainComponent 对象 ，这样在其它Activity中就可以通过获取Application的对象来inject 自己，这样创建出来的Person类就是一个单例子。1234567891011121314151617// Application MainComponent mMainComponent; SubComponent mSubComponent; @Override public void onCreate() &#123; super.onCreate(); &#125; public MainComponent getMainComponent() &#123; if(mMainComponent == null) mMainComponent = DaggerMainComponent.builder().build(); return mMainComponent; &#125;// Activity((App)getApplication()).getMainComponent().inject(this); 但是如果你不在Application中创建 MainComponent ，也就是在每个Activity都创建自己的MainComponent时，创建出来的Person类是不同的对象 ，说明在不同的MainComponent对象的时候，退即使使用了@Singleton 注解 ，最后创建的也不是单例。为了查明这个原因 ，我们查看Singleton的源码 ：1234@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; 它本身是一个Scope , 也没有特别的代码。那是不是我们自定义一个Scpoe也可以实现Singleton的效果呢，答案是肯定的。1234// 自定义的Scope @Scope@Retention(RetentionPolicy.RUNTIME)public @interface UserScope &#123;&#125; 自定义的Scope 使用方法与Singleton一样，把@Singleton换成@UserScope就可以了。通过多次验证的结果证明 : 用同一个component ，并声明同一个Scope ，创建出来的是同一个对象。 另外在看其它博客文章的时候，你会经常看到 @ActivityScope 可以声明一个Activity生命周期的对象 ，@ApplicationScope 可以声明一个Application生命周期的对象 ， 难道这些Scope这么神？ 定义一个名字就可以控制对象的生命周期了？ 其实这和 @Singleton一样的，都是代码是否通过同一个 component 对象来控制的。比如 @ActivityScope 定义的对象 ，其在Activity创建了component对象 ，那这个component对象肯定在这个Activity的生命周期内啊，依赖创建出来的对象也肯定是这个Activity啊。还有@ApplicationScope 中的component 对象是在 Application中的，那依赖创建出来的对象的生命周期也肯定是和 @Singleton的一样的，单例的生命周期不就是整个 Application 吗。 总结所以 Scope 的定义的名字不是控制对象生命周期的关键，取名 ActivityScope 、ApplicationScope、Singleton 只是让我们更好理解，提高代码可读性，真正控制对象生命周期的是 Component对象 。 参考 最简单的Dagger2入门教程 解锁Dagger2使用姿势（二） 之带你理解@Scope]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Tint属性优化Selector]]></title>
    <url>%2F2017%2F01%2F05%2F%E5%88%A9%E7%94%A8Tint%E5%B1%9E%E6%80%A7%E4%BC%98%E5%8C%96Selector%2F</url>
    <content type="text"><![CDATA[关于Selector的使用Selector中文的意思选择器，在Android中常常用来作组件的背景，这样做的好处是省去了用代码控制实现组件在不同状态下不同的背景颜色或图片的变换。使用十分方便。Selector就是状态列表（StateList）， 它分为两种，一种Color-Selector 和Drawable-Selector。一般使用语法如下：1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize=["true" | "false"]//drawable的大小是否当中状态变化，true表示是变化，false表示不变换，默认为false android:dither=["true" | "false"]//当位图与屏幕的像素配置不一样时(例如，一个ARGB为8888的位图与RGB为555的屏幕)会自行递色(dither)。设置为false时不可递色。默认true android:variablePadding=["true" | "false"] &gt;//内边距是否变化，默认false &lt;item android:drawable="@[package:]drawable/drawable_resource"//图片资源 android:state_pressed=["true" | "false"]//是否触摸 android:state_focused=["true" | "false"]//是否获取到焦点 android:state_hovered=["true" | "false"]//光标是否经过 android:state_selected=["true" | "false"]//是否选中 android:state_checkable=["true" | "false"]//是否可勾选 android:state_checked=["true" | "false"]//是否勾选 android:state_enabled=["true" | "false"]//是否可用 android:state_activated=["true" | "false"]//是否激活 android:state_window_focused=["true" | "false"] /&gt;//所在窗口是否获取焦点&lt;/selector&gt; 比如我们创建一个 DrawableSelector , 在/res/drawable/文件夹下新建btn_seletor.xml :12345&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/ic_btn_back_pressed" /&gt; &lt;item android:drawable="@drawable/ic_btn_back_normal" /&gt;&lt;/selector&gt; 调用时直接设置在android:background属性上 :12345&lt;Button android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:background="@drawable/btn_seletor"/&gt; 编译之后就能看到 点击按钮时，按钮图标就会变。 我们会发现，一般实现Selector的方法，需要以下两点 : 需要两张大小一样，表示不同状态效果的图片 创建一个selector的xml文件 但是两张状态效果一样的图片，除了颜色，其它都是一样的，我们能不能只用一张图片来实现，在代码里修改图片的颜色呢？ 答案当然是可以的，那就是利用android:tint属性。 如何使用tint 属性android:tint 是ImageView 特有的属性，所以我们用ImageView 来实现上面的例子，首先创建一个btn_single_seletor.xml, 注意使用的是同一张图片ic_btn_back_normal:12345&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/ic_btn_back_normal" /&gt; &lt;item android:drawable="@drawable/ic_btn_back_normal" /&gt;&lt;/selector&gt; 接着再创建image_color.xml 的 ColorDrawable , 并放在 /res/color/文件夹下 :12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true" android:color="#fac300" /&gt; &lt;item android:color="#00000000" /&gt;&lt;/selector&gt; 最后设置到 ImageView 上:1234567&lt;ImageView android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:tint="@color/image_color" android:src="@drawable/btn_single_seletor" android:clickable="true"/&gt; 编译之后就能看到 点击按钮时，效果与上面的例子是一样的。也许你会注意到在image_color.xml 中我们设置的颜色是#00000000 , 这是为了让图片不着色。如果我们一定要用Button来实现呢，但是Button没有android:src和android:tint属性怎么办？ 虽然在普通view可以设置这两个属性，但是没有效果。其实我们可以用android:background、android:backgroundTint属性，我们添加一个Button 如下 ：123456&lt;Button android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:background="@drawable/btn_single_seletor" android:backgroundTint="@color/image_color"/&gt; 编译安装之后你会发现，在普通状态时，按钮的图片是透明的，这和我们设置的普通状态下 tint color = #00000000”有关 , 不知道这是不是android的 bug ,为什么在src + tint 时就可以，在 background + backgroundTint 时就不行，知道答案的可以交流一下。 更优雅地使用 tint 属性在上面的例子中，我们设置了两个属性 ，其实我们可以只设置 android:background 或 android:src , 而不用设置 tint , 我们再添加 bitmap.xml :1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@drawable/ic_btn_back_normal" android:tint="#fac300" /&gt; 再新增 btn_notint_seletor.xml ， 添加 bitmap.xml :12345&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/bitmap" /&gt; &lt;item android:drawable="@drawable/ic_btn_back_normal" /&gt;&lt;/selector&gt; 最后设置到 ImageView 与 Button 上 ，去掉 android:tint 、android:backgroundTint属性:123456789101112&lt;ImageView android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:src="@drawable/btn_notint_seletor" android:clickable="true"/&gt;&lt;Button android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:background="@drawable/btn_notint_seletor"/&gt; 编译安装之后就能看到，效果与上面的例子是一样的。虽然添加多了一个bitmap.xml文件，但是我们免去了设置tint属性，不过上面的代码还可以再优化，就是去掉bitmap.xml , 我们在 btn_notint_seletor.xml 的基础上修改成 btn_notint_final_seletor.xml 文件：1234567&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;bitmap android:src="@drawable/ic_btn_back_normal" android:tint="#fac300" /&gt; &lt;/item&gt; &lt;item android:drawable="@drawable/ic_btn_back_normal" /&gt;&lt;/selector&gt; 重新设置成btn_notint_seletor之后，效果是一样的，而且代码更加简洁。这就是设置selector的最简洁的方式，我们只使用了一张图片，一个selector文件 就实现了效果。 使用 RotateDrawable 实现更多效果我们在实际开发中可能会经常碰到，左右翻页，上下翻页的情形，就是我们需要两张左右对称的图片，来实现左右箭头。如果加上点击效果的selector，那就需要4张图片了。如果我们用上面的方法，那也至少需要两张图片，那我们能不能在代码上实现图片的旋转呢，那就是使用 RotateDrawable 。 关于 RotateDrawable 的用法，可以参考这篇文章 ，我们创建一个btn_rotate_final_seletor.xml ：1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;rotate android:visible="true" android:fromDegrees="-180" android:pivotX="50%" android:pivotY="50%"&gt; &lt;bitmap android:src="@drawable/ic_btn_back_normal" android:tint="#fac300" /&gt; &lt;/rotate&gt; &lt;/item&gt; &lt;item&gt; &lt;rotate android:drawable="@drawable/ic_btn_back_normal" android:visible="true" android:fromDegrees="-180" android:pivotX="50%" android:pivotY="50%"&gt; &lt;/rotate&gt; &lt;/item&gt;&lt;/selector&gt; 重新设置成 Button的background之后，编译安装，效果实现了，而且还是左右对称的两个按钮。是不是觉得很简洁，我们只用了一张图片就实现了左右箭头的两个按钮。看看最终效果 : 总结使用这种方式来实现Selector ，不仅让代码更加简洁，而且省去了很多图片，减少了APK的大小。如果按平常的思路,在实现左右箭头的这个例子我们需要四张图片，平时一张图片至少也要几K 到 几十K，而现在只需要一张，减少了四分之三的大小。而且在后期中，如果要更改效果，我们只需要修改一下颜色值就可以了，炒鸡方便。 DemoDEMO 已经放在Github上了，有需要的可以去下载。https://github.com/zhooker/AndroidSelectorDemo 参考 Android中selector的使用 安卓着色器(tint)使用实践 Android Drawable Resource学习（十一）、RotateDrawable]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JavaScript基础] 闭包]]></title>
    <url>%2F2016%2F11%2F05%2FJavaScript%E5%9F%BA%E7%A1%80-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。总而言之，闭包是指有权访问另一个函数作用域中的变量的函数。 下面就是我的学习笔记，对于Javascript初学者应该是很有用的。 一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。12345 var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。1234 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！12345 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。123456 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 三、闭包的概念上一节代码中的f2函数，就是闭包。各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除（用delete），或主动设置引用为null。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JavaScript基础] JavaScript中的判断]]></title>
    <url>%2F2016%2F10%2F25%2FJavaScript%E5%9F%BA%E7%A1%80-JavaScript%E4%B8%AD%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[1. == 与 === 的区别== (equality 等同)两边值类型不同的时候，要先进行类型转换，再比较。=== (identity 恒等)不做类型转换，类型不同的一定不等。 “===”严格运算符的运算规则(1)不同类型值 : 如果两个值的类型不同，直接返回false。 (2)同一类的原始类型值 : 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。 (3)同一类的复合类型值 : 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。 (4)undefined和null : undefined 和 null 与自身严格相等,它们互相比较时结果为false , 这是与==不同的地方。 (5) NaN ：NaN与其它符号对比都返回false,判断两个NaN时返回的是false，所以只能用isNaN或Object.is()来判断 12null === null //trueundefined === undefined //true 当然，严格相等运算符 === 也不会对操作数进行类型转换，但是它会把 -0 和 +0 这两个数值视为相同的，还会把两个 NaN 看成是不相等的 “==”严格运算符的运算规则“==”相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下： (1)原始类型的值 : 原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值。基本类型的值转换成布尔型时的规则：|数据类型| 转换成true的取值| 转换成false的取值||:-:|:-:|:-:|Undefined| 无| undefined|Boolean| true| false|Object| 非null时都为true| nullNumber| 非0和NaN时都为true| 0和NaNString|非空字符串| “”(空字符串) (2)对象与原始类型值比较 : 对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。 (3)undefined和null : undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 (4)相等运算符的缺点 : 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。 (5) NaN ：NaN与其它符号对比都返回false,判断两个NaN时返回的是false，所以只能用isNaN或Object.is()来判断 2. Object.is()用一个表达式来检查当前选择的元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。如果没有元素符合，或者表达式无效，都返回’false’。 Object.is() 会在下面这些情况下认为两个值是相同的： 两个值都是 undefined 两个值都是 null 两个值都是 true 或者都是 false 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且 都是正零 +0 都是负零 -0 都是 NaN 都是除零和 NaN 外的其它同一个数字 Object.is() 与 === 的区别 ： Object.is()对比两个NaN时返回true, Object.is()判断+0 -0时返回false , 而===则相反。 3. 三个判断符号之间的区别 4.例子：12345678910111213141516171819202122232425262728293031323334353637383940414243&apos;&apos; == &apos;0&apos; // false0 == &apos;&apos; // true0 == &apos;0&apos; // truefalse == &apos;false&apos; // falsefalse == &apos;0&apos; // truefalse == undefined // falsefalse == null // falsenull == undefined // true&apos; \t\r\n &apos; == 0 // true这就是为什么建议尽量不要使用相等运算符。var a = undefined;if(!a)&#123; console.log(&quot;1&quot;); //1&#125;var a = undefined;if(a == null)&#123; console.log(&quot;1&quot;); //1&#125;var a = undefined;if(a === null)&#123; console.log(&quot;1&quot;); //无输出&#125;Object.is(&apos;foo&apos;, &apos;foo&apos;); // trueObject.is(window, window); // trueObject.is(&apos;foo&apos;, &apos;bar&apos;); // falseObject.is([], []); // falsevar test = &#123; a: 1 &#125;;Object.is(test, test); // trueObject.is(null, null); // true// 特例Object.is(0, -0); // falseObject.is(-0, -0); // trueObject.is(NaN, 0/0); // true]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JavaScript生成Loading效果]]></title>
    <url>%2F2016%2F10%2F20%2F%E7%94%A8JavaScript%E7%94%9F%E6%88%90Loading%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[一个简单的loading效果，用四个符号(-、\、|、/) 来模拟一个不断旋转的小东东，以提示用户当前正在载入中，ArcLive 上为玩家建立连线时便是这样显示的，呵呵。 1234567891011121314&lt;span id="loadin"&gt;-&lt;/span&gt;&lt;script type="text/javascript"&gt;function easy_loading(id) &#123; var symbol = ['-', '\\', '|', '/'], elem = document.getElementById(id), i = 0; (function __func() &#123; elem.innerHTML = symbol[i++ % 4]; setTimeout(__func, 200); &#125;)();&#125;easy_loading('loadin');&lt;/script&gt; 为了避免可能出现的阻塞浏览器线程的情况，这里用setTimeout 代替了setInterval。setTimeout()的使用方法 setTimeout()的使用方法setTimeout (表达式，延时时间)、setTimeout(表达式，交互时间)，延时时间/交互时间是以豪秒为单位的(1000ms=1s)。 setTimeout 在执行时，是在载入后延迟指定时间后，去执行一次表达式，仅执行一次。setTimeout 在执行时，它从载入后，每隔指定的时间就执行一次表达式。 基本用法 ：123456789101112131415//执行一段代码：var i=0;setTimeout("i+=1;alert(i)",1000);//执行一个函数：var i=0;setTimeout(function()&#123;i+=1;alert(i);&#125;,1000);//下面再来一个执行函数的：var i=0; function test()&#123; i+=1; alert(i); &#125; setTimeout("test()",1000); 用setTimeout实现setInterval的功能思路很简单，就是在一个函数中调用不停执行自己，有点像递归。12345678var i=0; function xilou()&#123; i+=1; if(i&gt;10)&#123;alert(i);return;&#125; setTimeout("xilou()",1000); //用这个也可以 //setTimeout(xilou,1000); &#125;]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript渐变效果的实现]]></title>
    <url>%2F2016%2F10%2F12%2FJavaScript%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 clearInterval() 方法可取消由 setInterval() 设置的 timeout。参数必须是由 setInterval() 返回的 ID 值。 效果： 当鼠标移上去透明度渐渐增加，鼠标移出，透明度渐渐减小。 关键代码：123456var speed = 0;if(target&gt;obj.alpha)&#123; speed = 5;&#125;else&#123; speed = -5;&#125; 根据目标值和当时值的对比，来决定是正向还是负向速度。12345678910for(i=0; i &lt; runs_li.length; i++)&#123; runs_li[i].timer = null; runs_li[i].alpha = 30; runs_li[i].onmouseover = function()&#123; startrun(this,100); &#125; runs_li[i].onmouseout = function()&#123; startrun(this,30); &#125;&#125; 给每一个元素加上各自的透明度值，各自的透明度变化分开。 全部代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt;#runs&#123;width:300px; margin:10px auto;&#125;#runs li&#123;width:80px; height:80px; background:#06c; list-style:none; float:left; margin:10px; display:inline; filter:alpha(opacity=30); opacity:0.3;&#125;&lt;/style&gt;&lt;script&gt;window.onload = function()&#123; var runs = document.getElementById("runs"); var runs_li = runs.getElementsByTagName("li"); var i=0; for(i=0; i&lt;runs_li.length; i++)&#123; runs_li[i].timer = null; runs_li[i].alpha = 30; runs_li[i].onmouseover = function()&#123; startrun(this,100); &#125; runs_li[i].onmouseout = function()&#123; startrun(this,30); &#125; &#125;&#125;function startrun(obj,target)&#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var speed = 0; if(target&gt;obj.alpha)&#123; speed = 5; &#125;else&#123; speed = -5; &#125; if(obj.alpha == target)&#123; clearInterval(obj.timer); &#125;else&#123; obj.alpha = obj.alpha + speed; obj.style.filter = "alpha(opacity="+obj.alpha+")"; obj.style.opacity = obj.alpha/100; &#125; &#125;,30)&#125;&lt;/script&gt;&lt;ul id="runs"&gt; &lt;li&gt;简&lt;/li&gt; &lt;li&gt;明&lt;/li&gt; &lt;li&gt;现&lt;/li&gt; &lt;li&gt;代&lt;/li&gt; &lt;li&gt;魔&lt;/li&gt; &lt;li&gt;法&lt;/li&gt;&lt;/ul&gt;]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hybrid应用开发入门]]></title>
    <url>%2F2016%2F09%2F27%2FHybrid%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言Hybrid应用说白了就是NativeAPP与WebAPP的混合开发， Native APP就是利用Android SDK开发的Android应用，而Web APP是利用WebView来呈现网页页面的应用，但是编写网页页面需要具备HTML5、JavaScript的知识，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势。 Native与WebView的进行交互1.Native调用JS我们知道如果Native需要调用Js中的方法，只需要使用WebView:loadUrl();方法即可直接调用指定Js代码中的函数，如：1mWebView.loadUrl("javascript:setUserName('zhooker');"); 2.JS调用Native1.传统的JSInterface最普通的一种通信方式，就是使用Android原生的JavascriptInterface来进行js和java的通信。首先先看一段html代码1234567891011121314151617181920&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" dir="ltr"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;script type="text/javascript"&gt; function showToast(toast) &#123; javascript:control.showToast(toast); &#125; function log(msg)&#123; console.log(msg); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="toast" onClick="showToast('Hello world')" /&gt;&lt;/body&gt;&lt;/html&gt; 当我们点击了按钮之后，会调用JS的showToast(),并调用到control.showToast(),我们接着看一下java层的代码：123456789101112131415161718192021222324252627282930313233@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); webView = (WebView)findViewById(R.id.webView); WebSettings webSettings = webView.getSettings(); webSettings.setJavaScriptEnabled(true); webView.addJavascriptInterface(new JsInterface(), "control"); webView.loadUrl("file:///android_asset/interact.html");&#125;public class JsInterface &#123; @JavascriptInterface public void showToast(String toast) &#123; Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show(); log("show toast success"); &#125; public void log(final String msg)&#123; webView.post(new Runnable() &#123; @Override public void run() &#123; webView.loadUrl("javascript: log(" + "'" + msg + "'" + ")"); &#125; &#125;); &#125;&#125; 首先界面很简单，一个WebView。在对应的activity中做的事也就几件，首先打开js通道。12WebSettings webSettings = webView.getSettings();webSettings.setJavaScriptEnabled(true); 然后通过WebView的addJavascriptInterface方法去注入一个我们自己写的interface。可以看到这个interface我们给它取名叫control。这个就对应于刚才html代码中的control。1webView.addJavascriptInterface(new JsInterface(), "control"); 最后loadUrl。1webView.loadUrl("file:///android_asset/interact.html"); 但是使用这种方式你就要小心XSS攻击了，虽然这个漏洞已经在Android4.2上修复了，就是使用@JavascriptInterface这个注解。但是你得考虑兼容性啊，你不能保证，尤其在中国这样碎片化严重的地方，每个用户使用的都是4.2+的系统。所以基本上我们不会再利用Android系统为我们提供的addJavascriptInterface方法或者@JavascriptInterface注解来实现js和java的通信了。那怎么办呢？方法都是人想出来的嘛，下面让我们看解决方案。 2.JSBridge方式JSBridge，顾名思义，就是和js沟通的桥梁。其实这个技术在Android中已经不算新了，相信有些同学也看到过不少实现方案，这里说一种我的想法吧。首先先说思路，有经验的同学可能都知道Android的WebView中有一个WebChromeClient类，这个类其实就是用来监听一些WebView中的事件的，我们发现其中有三个这样的方法。 1234567891011121314@Overridepublic boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; return super.onJsPrompt(view, url, message, defaultValue, result);&#125;@Overridepublic boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; return super.onJsAlert(view, url, message, result);&#125;@Overridepublic boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123; return super.onJsConfirm(view, url, message, result);&#125; 这三个方法其实就对应于js中的alert(警告框)，comfirm(确认框)和prompt(提示框)方法，。比如我们可以在js脚本中调用alert方法，这样对应的就会走到WebChromeClient类的onJsAlert()方法中，我们就可以拿到其中的信息去解析，并且做java层的事情。在js中，alert和confirm的使用概率还是很高的，特别是alert，所以我们最好不要使用这两个通道，以免出现不必要的问题。所以我们可以通过重写WebView中WebChromeClient类的onJsPrompt()方法来进行js和java的通信。我们可以定义一个自己的协议，通过js脚本把这段协议文本传递到onPropmt()方法中并且进行解析，在onPropmt()解析对应的URL之后就可以去执行对应的java代码了。一般URL的格式为：scheme://host:port/path?query，对应的我们协定prompt传入message的格式为: jsbridge://class:port/method?params。先看一下我们html和js的代码1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="file:///android_asset/jsBridge.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="blog-header"&gt; &lt;h3&gt;JSBridge&lt;/h3&gt;&lt;/div&gt;&lt;ul class="entry"&gt; &lt;br/&gt; &lt;li&gt; toast展示&lt;br/&gt; &lt;button onclick="JsBridge.call('JSBridge','toast',&#123;'message':'我是气泡','isShowLong':0&#125;,function(res)&#123;&#125;);"&gt;toast&lt;/button&gt; &lt;/li&gt; &lt;br/&gt; &lt;li&gt; 异步任务&lt;br/&gt; &lt;button onclick="JsBridge.call('JSBridge','plus',&#123;'data':1&#125;,function(res)&#123;console.log(JSON.stringify(res))&#125;);"&gt;plus&lt;/button&gt; &lt;/li&gt; &lt;br/&gt; &lt;br/&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 点击按钮会执行js脚本的这段代码12345678910111213call: function (obj, method, params, callback, timeout) &#123; var sid; if (typeof callback !== 'function') &#123; callback = null; &#125; sid = Private.getSid(); Private.registerCall(sid, callback); Private.callMethod(obj, method, params, sid);&#125; 然后在call这个方法内，会执行Private类的registerCall和callMethod，我们来看callMehod()。12345678910//生成URI，调用native功能callMethod: function (obj, method, params, sid) &#123; // hybrid://objectName:sid/methodName?params params = Private.buildParam(params); var uri = LOCAL_PROTOCOL + '://' + obj + ':' + sid + '/' + method + '?' + params; var value = CB_PROTOCOL + ':'; window.prompt(uri, value);&#125; 以界面的第一个按钮toast为例，点击这个按钮，它会执行相应的js脚本代码，然后就会像我们前面所讲的那样，走到onJsPrompt()方法中，下面让我们看看对应的java代码。123456789101112131415public class InjectedChromeClient extends WebChromeClient &#123; private final String TAG = "InjectedChromeClient"; private JsCallJava mJsCallJava; public InjectedChromeClient() &#123; mJsCallJava = new JsCallJava(); &#125; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; result.confirm(mJsCallJava.call(view, message)); return true; &#125;&#125; 我们传给JsCallJava类的那个message，就像我们前面定义的协议一样。sheme是hybrid://，表示这是一个hybrid方法，host是JSBridge，方法名字是toast，传递的参数是以json格式传递的，具体内容如图。不知道大家有没有发现，这里我有一个东西没有讲，就是JSBridge:后面的那串数字，这串数字是干什么用的呢？大家应该知道，现在我们整个调用过程都是同步的，这意味着我们没有办法在里面做一些异步的操作，为了满足异步的需求，我们就需要定义这样的port，有了这串数字，我们在java层就可以做异步的操作，等操作完成以后回调给js脚本，js脚本就通过这串数字去得到对应的callback，有点像startActivity中的那个requestCode。Java层通过onJsPrompt获取到URl后，URL形式如hybrid://JSBridge:875725/toast?{“message”:”我是气泡”,”isShowLong”:0},就可以通过解析URL，再通过反射的方法去调用对应的函数。最后总结一下JSBridge的流程： 在js脚本中把对应的方法名，参数等写成一个符合协议的uri，并且通过window.prompt方法发送给java层。 在java层的onJsPrompt方法中接受到对应的message之后，通过JsCallJava类进行具体的解析。 在JsCallJava类中，我们解析得到对应的方法名，参数等信息，并且在map中查找出对应的类的方法。参考文章 Native与H5交互的那些事 好好和h5沟通！几种常见的hybrid通信方式 源码 RainbowBridge]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava使用指南]]></title>
    <url>%2F2016%2F09%2F11%2FRxJava%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言RxJava的开发模式越来越受开发者欢迎，响应式的编程不仅可以减少代码量，还增加了代码的可读性，让开发维护再加简单。RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。 一.什么是RxJavaRxJava其实就是一个工具库，使用的就是通用形式的观察者模式。RxJava最核心的两个东西是Observables（被观察者，事件源）和Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西（触摸事件，web接口调用返回的数据。。。）一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onComplete()或者Subscriber.onError()结束。Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。 二.为什么要用RxJavaRxJava 优点主要是让代码简洁，增加代码的可读性，随着程序逻辑变得越来越复杂，它依然能够保持简洁。我们想你一下这么一个场景：我们要从外部存储器中加载一张图片，并把图片转化成Bitmap并显示到ImageView中，如果我们按照非RxJava的开发方式，我们就要先创建一个异步线程（Thread、AsyncTask等）用来执行耗时的图片加载任务，之后再在主线程新建一个Handler用来更新ImageView。大概的代码是这样实现的：12345678910111213new Thread() &#123; @Override public void run() &#123; super.run(); final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的：123456789101112131415Observable.from(folders) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); 虽然代码量并没有减少，但是用了RxJava之后代码的逻辑会很清晰， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显。假设你要加载10张图片，并且只加载png格式的，加载完还要切割成圆角，在非RxJava的实现上，势必会添加10张图的循环嵌套，再增加一个isPNG()的判断函数，一个圆角切割函数toRoundBitmap(),势必会对代码逻辑一个大修改，而使用RxJava，我们只需要在链式调用上添加必要的处理函数就行了，添加代码如下：123456789101112131415161718.flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(".png"); &#125; &#125;).map(new Func1&lt;Bitmap, Bitmap&gt;() &#123; @Override public Bitmap call(Bitmap origin) &#123; return toRoundBitmap(origin); &#125; &#125;) 特别是如果你的 IDE 是 Android Studio ，其实每次打开某个 Java 文件的时候，你会看到被自动 Lambda 化的预览，这将让你更加清晰地看到程序逻辑。 三.如何使用RxJava1.添加依赖库 compile &#39;io.reactivex:rxjava:1.1.6&#39; compile &#39;io.reactivex:rxandroid:1.2.1&#39; RxAndroid 是RxJava在Android运行环境的补充库。 1.创建 Observer1234567891011121314Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, "Item: " + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, "Completed!"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, "Error!"); &#125;&#125;; onCompleted() : 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。 onError() : 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。在一个正确运行的事件序列中, onCompleted() 和 onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的。选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点： onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。 unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 2.创建 ObservableObservable 即被观察者，它决定触发事件的逻辑，即什么时候调用onNext，什么时候调用onComplete。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则：123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("Hello"); subscriber.onNext("Hi"); subscriber.onNext("Aloha"); subscriber.onCompleted(); ]\ &#125;&#125;); RxJava 还提供了一些方法用来快捷创建事件队列，例如：just(T...): 将传入的参数依次发送出来。123456Observable observable = Observable.just("Hello", "Hi", "Aloha");// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted(); from(T[]) / from(Iterable&lt;? extends T&gt;): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。1234567String[] words = &#123;"Hello", "Hi", "Aloha"&#125;;Observable observable = Observable.from(words);// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted(); 3. Subscribe (订阅)创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：12observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 订阅之后 ，将会依次输出 “Item: Hello”, “Item: Hi”, “Item: Aloha” , “Completed!”。 4.线程控制 Scheduler默认情况下，即在没有任务设置的时候，Observable和Observer都在同一线程中执行，即创建了这两个对象的线程，相当于设置了Schedulers.immediate()。如果想在异步线程中执行，就要设置成Schedulers.newThread()或Schedulers.io() , 他们两个的区别是io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，而Schedulers.newThread() 总是启用新线程，并在新线程执行操作因此多数情况下io()比 newThread()更有效率。不要把计算工作放 io() 中，可以避免创建不必要的线程。 subscribeOn: 设置OnSubscribe运行的线程 observeOn: 设置Observer运行的线程 5.常用函数解析 map : 是转化成另一个类型的输出 compose : 也是一个转化，传的是一个Transformer,可以转化为Obserables添加参数，这个是高级的转化，不像flatmap,如果Obserables传的是数组，那会一个一个传，而compose会直接传数组。 filter : 过滤 interval , timer : 定时执行任务 delay ： 延时发送结果 5.在什么场景下使用RxJava 可以用Observable.concat(memory, disk, network).first(new Fun1(){}) 实现类似事件拦截机制。比如取数据先检查缓存的场景。注意此时的onCompleted只会调用一次。 可以用Observable.merge(observable1, observable2) 实现需要等到多个接口并发取完数据，再更新的情况。注意此时的onCompleted只会调用一次。 flatmap 主要转化成另一个Obserables，可以用flatmap实现一个接口的请求依赖另一个API请求返回的数据的场景。比如我们从网络获取到的列表，还要从本地数据库中取得缓存的列表，对比后再刷新出来。利用flatmap还能创建出更多嵌套的代码，而保持代码的简洁性，还有比如我们从SD搜索图片并加载成Bitmap，就可以用flatmap对每个子目录再搜索。 可以用filter、map执行一些复杂的数据变换。 参考文章 RxJava使用场景小结 给 Android 开发者的 RxJava 详解]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
</search>