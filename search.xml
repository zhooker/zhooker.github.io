<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(转)使用注解改进代码检查]]></title>
    <url>%2F2017%2F04%2F22%2F%E8%BD%AC-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%94%B9%E8%BF%9B%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[使用代码检查工具（例如 Lint）可以帮助您找到问题并改进代码，不过，检查工具只能推断这么多信息。例如，Android 资源 ID 使用 int 标识字符串、图形、颜色和其他资源类型，因此，检查工具无法告诉您何时指定字符串资源以及应在什么地方指定颜色。在这种情况下，您的应用可能无法正确渲染或根本无法运行，即使使用代码检查也是如此。您可以使用注解向 Lint 之类的代码检查工具提供提示，帮助检测这些更细微的代码问题。您可以将注解作为元数据标记附加至变量、参数和返回值，用于检查方法返回值、传递的参数以及本地变量和字段。如果与代码检查工具搭配使用，注解可以帮助您检测问题，例如 null 指针异常和资源类型冲突。Android 通过注解支持库支持各种注解。您可以通过 android.support.annotation 软件包获取该库。 向您的项目添加注解要在您的项目中启用注解，请向您的库或应用添加 support-annotations 依赖项。添加的任何注解都会在您随后运行代码检查或 lint任务时进行检查。 添加支持注解库依赖项支持注解库是 Android 支持库的一部分。要向您的项目添加注解，您必须下载支持存储库并向 build.gradle 文件中添加 support-annotations 依赖项。 打开 SDK 管理器，方法是点击工具栏中的 SDK Manager 图标 或者选择 Tools &gt; Android &gt; SDK Manager。 点击 SDK Tools 标签。 展开 Support Repository 并选中 Android Support Repository 复选框。 点击 OK。 继续安装向导的说明操作，安装软件包。 将以下代码行添加到 build.gradle 文件的 dependencies 块中，向您的项目添加 support-annotations 依赖项： 1dependencies &#123; compile com.android.support:support-annotations:24.2.0' &#125; 您下载的库版本可能较高，因此，确保您在此指定的值与第 3 步中的版本匹配。 在显示的工具栏或同步通知中，点击 Sync Now。 如果您在自己的库模块中使用注解，注解将作为 Android 归档 (AAR) 工件的一部分以 XML 格式添加到 annotations.zip 文件中。添加 support-annotations 依赖项不会为您的库的任何下游用户引入依赖关系。如果想要在未使用适用于 Gradle 的 Android 插件但使用 Gradle Java 插件的 Gradle 模块中使用注解（com.android.application 或 com.android.library），您必须明确添加 SDK 存储库，因为无法从 JCenter Java 存储库获得 Android 支持库：1repositories &#123; jcenter() maven &#123; url '&lt;your-SDK-path&gt;/extras/android/m2repository' &#125;&#125; 注：如果您使用 appcompat 库，则无需添加 support-annotations 依赖项。因为 appcompat 库已经依赖注解库，您可以访问相关注解。要查看支持存储库中包含的完整注解列表，请查看支持注解库参考，或者使用自动填充功能显示 import android.support.annotation. 语句的可用选项。 运行代码检查要从 Android Studio 启动代码检查（包含验证注解和自动 Lint 检查），请从菜单栏中选择 Analyze &gt; Inspect Code。Android Studio 将显示冲突消息，在您的代码与注解冲突的地方标记潜在问题并建议可能的解决方法。您还可以通过使用命令行运行 lint 任务来强制注解。尽管这对标记持续集成服务器遇到的问题可能有用，请注意，lint 任务并不会强制 nullness 注解（只有 Android Studio 会强制）。如需了解有关启用和运行 Lint 检查的详细信息，请参阅使用 Lint 改进您的代码。请注意，尽管注解冲突会生成警告，但这些警告不会阻止您的应用编译。 Nullness 注解添加 @Nullable 和 @NonNull 注解，以检查给定变量、参数或返回值的 nullness。@Nullable 注解指示可以为 null 的变量、参数或返回值，而 @NonNull 则指示不可为 null 的变量、参数或返回值。例如，如果一个包含 null 值的局部变量作为已附加 @NonNull 注解的参数传递到某个方法，则构建代码将生成一个指示非 null 冲突的警告。另一方面，对于通过 @Nullable 标记的方法的结果，如果不先检查其是否为 null，那么在尝试引用它时将生成 nullness 警告。只有在每次使用方法时都应明确检查是否为 null 的情况下，才应对方法返回值使用 @Nullable 。下面的示例会将 @NonNull 注解附加到 context 与 attrs 参数，以检查传递的参数值是否不为 null。它还会检查 onCreateView() 方法本身是否不会返回 null：123456789import android.support.annotation.NonNull;/** Add support for inflating the &lt;fragment&gt; tag. **/ @NonNull @Override public View onCreateView(String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; ... &#125; Nullability 分析Android Studio 支持通过运行 nullability 分析，在您的代码中自动推断和插入 nullness 注解。Nullability 分析会在您代码的整个方法层次结构中扫描协定类，以检测： 可返回 Null 的调用方法 不会返回 Null 的方法 可以为 Null 的变量，如字段、局部变量和参数 不能为 Null 值的变量，如字段、局部变量和参数 然后，此分析将自动在已检测到的位置插入相应的 null 注解。要在 Android Studio 中运行 nullability 分析，请选择 Analyze &gt; Infer Nullity。Android Studio 会在代码中已检测到的位置插入 Android @Nullable 和 @NonNull 注解。运行 null 分析后，最好验证一下插入的这些注解。 注：添加 nullness 注解时，自动填充可能会建议 IntelliJ @Nullable 和 @NotNull 注解而不是 Android null 注解，并且可能会自动导入相应的库。不过，Android Studio Lint 检查器仅会查找 Android null 注解。验证您的注解时，请确认您的项目使用 Android null 注解，以便 Lint 检查器可以在代码检查期间正确通知您。 资源注解验证资源类型可能非常有用，因为 Android 对资源（例如可绘制对象和字符串资源）的引用以整型形式传递。需要参数来引用特定类型资源（例如可绘制对象）的代码可以作为预计的引用类型 int 传入，不过实际将引用不同类型的资源，例如 R.string 资源。例如，添加 @StringRes 注解，以检查资源参数是否包含 R.string 引用，如下面所示：1public abstract void setTitle(@StringRes int resId) &#123; … &#125; 在代码检查期间，如果参数中未传入 R.string 引用，注解将生成警告。其他资源类型的注解（例如 @DrawableRes、@DimenRes、@ColorRes 和 @InterpolatorRes）可以使用相同的注解格式添加并在代码检查期间运行。如果您的参数支持多种资源类型，您可以在给定参数上添加更多注解。使用 @AnyRes 能够指示注解的参数可为任意类型的 R 资源。尽管您可以使用 @ColorRes 指定某个参数应为颜色资源，但是颜色整型（RRGGBB 或 AARRGGBB 格式）无法识别为颜色资源。请改用 @ColorInt 注解指示某个参数必须为颜色整型。构建工具会标记不正确代码，该代码会将颜色资源 ID（例如 android.R.color.black）而不是颜色整型传递到已注解方法。 线程注解线程注解可以检查某个方法是否从特定类型的线程调用。支持以下线程注解： @MainThread @UiThread @WorkerThread @BinderThread @AnyThread 注：构建工具会将 @MainThread 和 @UiThread 注解视为可互换，因此，您可以从 @MainThread 方法调用 @UiThread 方法，反之亦然。不过，如果系统应用在不同线程上带有多个视图，UI 线程可与主线程不同。因此，您应使用 @UiThread 标注与应用的视图层次结构关联的方法，使用 @MainThread 仅标注与应用生命周期关联的方法。 如果某个类中的所有方法具有相同的线程要求，您可以向该类添加一个线程注解，以验证该类中的所有方法是否均从相同类型的线程调用。线程注解的一个常见用途是验证 AsyncTask 类中的方法替换，因为此类会执行后台操作并将结果仅发布到 UI 线程上。 值约束注解使用 @IntRange、@FloatRange 和 @Size 注解可以验证传递的参数的值。在应用到用户可能弄错其范围的参数时，@IntRange 和 @FloatRange 都非常有用。@IntRange 注解可以验证整型或长整型参数值是否位于指定范围内。下面的示例可以确保 alpha 参数包含 0 至 255 范围内的整数值：1public void setAlpha(@IntRange(from=0,to=255) int alpha) &#123; … &#125; @FloatRange 注解可以检查浮点或双整型参数值是否位于指定的浮点值范围内。下面的示例可以确保 alpha 参数包含 0.0 至 1.0 的浮点值：1public void setAlpha(@FloatRange(from=0.0, to=1.0) float alpha) &#123;...&#125; @Size 注解可以检查集合或数组的大小，以及字符串的长度。@Size 注解可用于验证以下质量： 最小大小（例如 @Size(min=2)） 最大大小（例如 @Size(max=2)） 确切大小（例如 @Size(2)） 表示大小必须为此倍数的数字（例如 @Size(multiple=2)） 例如，@Size(min=1) 可以检查某个集合是否不为空，@Size(3) 可以验证某个数组是否刚好包含三个值。下面的示例可以确保 location数组至少包含一个元素：1int[] location = new int[3];button.getLocationOnScreen(@Size(min=1) location); 权限注解使用 @RequiresPermission 注解可以验证方法调用方的权限。要检查有效权限列表中是否存在某个权限，请使用 anyOf 属性。要检查是否存在一组权限，请使用 allOf 属性。下面的示例会标注 setWallpaper() 方法，以确保方法的调用方拥有 permission.SET_WALLPAPERS 权限：12@RequiresPermission(Manifest.permission.SET_WALLPAPER)public abstract void setWallpaper(Bitmap bitmap) throws IOException; 此示例要求 copyFile() 方法的调用方同时具有外部存储空间的读写权限：12@RequiresPermission(allOf = &#123; Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;)public static final void copyFile(String dest, String source) &#123; ...&#125; 对于 intent 权限，请将权限要求添加到定义 intent 操作名称的字符串字段上：12@RequiresPermission(android.Manifest.permission.BLUETOOTH)public static final String ACTION_REQUEST_DISCOVERABLE = "android.bluetooth.adapter.action.REQUEST_DISCOVERABLE"; 对于您需要单独读写权限的内容提供程序的权限，请在 @RequiresPermission.Read 或 @RequiresPermission.Write 注解中包含每个权限要求：123@RequiresPermission.Read(@RequiresPermission(READ_HISTORY_BOOKMARKS))@RequiresPermission.Write(@RequiresPermission(WRITE_HISTORY_BOOKMARKS))public static final Uri BOOKMARKS_URI = Uri.parse("content://browser/bookmarks"); 间接权限如果权限依赖于提供给方法参数的特定值，请对参数本身使用 @RequiresPermission，而不用列出具体权限。例如，startActivity(Intent)) 方法会对传递到方法的 intent 使用间接权限：1public abstract void startActivity(@RequiresPermission Intent intent, @Nullable Bundle) &#123;...&#125; 在您使用间接权限时，构建工具将执行数据流分析以检查传递到方法的参数是否具有任何 @RequiresPermission 注解。随后，它们会对方法本身强制参数的任何现有注解。在 startActivity(Intent) 示例中，当一个不具有相应权限的 intent 传递到方法时，Intent 类中的注解会针对 startActivity(Intent) 的无效使用生成警告，如图 1 中所示。图 1. startActivity(Intent) 方法上从间接权限注解生成的警告。构建工具会在 startActivity(Intent) 上从 Intent 类中相应 intent 操作名称的注解生成警告：123@SdkConstant(SdkConstantType.ACTIVITY_INTENT_ACTION)@RequiresPermission(Manifest.permission.CALL_PHONE)public static final String ACTION_CALL = "android.intent.action.CALL"; 如果需要，在标注方法的参数时，您可以将 @RequiresPermission 替换为 @RequiresPermission.Read 和/或 @RequiresPermission.Write。不过，间接权限 @RequiresPermission 不应与读取或写入权限注解搭配使用。 返回值注解使用 @CheckResult 注解可以验证实际使用的是方法的结果还是返回值。添加注释来阐明可能令人困惑的方法的结果，而不是使用 @CheckResult 标注每个非空方法。例如，新 Java 开发者经常误认为 &lt;String&gt;.trim() 会移除原始字符串中的空格。使用 @CheckResult标注方法会在调用方未对方法返回值作任何处理的地方标记 &lt;String&gt;.trim()的使用。下面的示例会标注 checkPermissions()) 方法，以确保实际引用方法的返回值。它还会将 enforcePermission() 方法指定为要向开发者建议的替换方法：12@CheckResult(suggest="#enforcePermission(String,int,int,String)")public abstract int checkPermission(@NonNull String permission, int pid, int uid); CallSuper 注解使用 @CallSuper 注解可以验证替换方法是否会调用方法的超类实现。下面的示例会标注 onCreate() 方法，以确保任何替换方法实现都会调用 super.onCreate() ：1@CallSuperprotected void onCreate(Bundle savedInstanceState) &#123;&#125; Typedef 注解使用 @IntDef 和 @StringDef 注解，以便能够创建整型和字符串集的枚举注解来验证其他类型的代码引用。Typedef 注解可以确保特定参数、返回值或字段引用特定的常量集。它们还可以完成代码以自动提供允许的常量。Typedef 注解使用 @interface声明新的枚举注解类型。@IntDef 和 @StringDef 注解以及 @Retention 可以标注新注解，并且为定义枚举的类型所必需。@Retention(RetentionPolicy.SOURCE) 注解可以告知编译器不将枚举的注解数据存储在 .class 文件中。下面的示例说明了创建注解的具体步骤，此注解可以确保作为方法参数传递的值引用一个定义的常量：12345678910111213141516import android.support.annotation.IntDef;public abstract class ActionBar &#123; // Define the list of accepted constants and declare the NavigationMode annotation @Retention(RetentionPolicy.SOURCE) @IntDef(&#123;NAVIGATION_MODE_STANDARD, NAVIGATION_MODE_LIST, NAVIGATION_MODE_TABS&#125;) public @interface NavigationMode &#123;&#125; // Declare the constants public static final int NAVIGATION_MODE_STANDARD = 0; public static final int NAVIGATION_MODE_LIST = 1; public static final int NAVIGATION_MODE_TABS = 2; // Decorate the target methods with the annotation @NavigationMode public abstract int getNavigationMode(); // Attach the annotation public abstract void setNavigationMode(@NavigationMode int mode); 在您构建此代码时，如果 mode 参数不引用一个定义的常量（NAVIGATION_MODE_STANDARD、NAVIGATION_MODE_LIST 或 NAVIGATION_MODE_TABS），则会生成警告。您还可以组合 @IntDef 和 @IntRange，以指示整型可以是给定的常量集或某个范围内的值。 允许将常量与标志相结合如果用户可以将允许的常量与标志（例如，|、&amp; 和 ^，等等）相结合，则您可以通过 flag 属性定义一个注解，以检查某个参数或返回值是否会引用有效模式。下面的示例将使用一组有效的 DISPLAY_ 常量创建 DisplayOptions 注解：1234567import android.support.annotation.IntDef;...@IntDef(flag=true, value=&#123; DISPLAY_USE_LOGO, DISPLAY_SHOW_HOME, DISPLAY_HOME_AS_UP, DISPLAY_SHOW_TITLE, DISPLAY_SHOW_CUSTOM&#125;)@Retention(RetentionPolicy.SOURCE)public @interface DisplayOptions &#123;&#125;... 在您使用注解标志构建代码时，如果经过修饰的参数或返回值不引用有效模式，则将生成警告。 代码可访问性注解使用 @VisibleForTesting 和 @Keep 注解可以表示方法、类或字段的可访问性。@VisibleForTesting 注解指示一个代码块的可见性是否高于让代码变得可测试所需要的水平。@Keep 注解可以确保如果在构建时缩减代码，标注的元素不会移除。它一般会添加到通过反射访问的方法和类中，以阻止编译器将代码视为未使用。 另请参阅使用 Lint 改进您的代码Android Studio 中的注解]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中容易出错的笔试题]]></title>
    <url>%2F2017%2F04%2F16%2FJava%E4%B8%AD%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[下面有关List接口、Set接口和Map接口的描述，错误的是？A、他们都继承自Collection接口B、List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置C、Set是一种不包含重复的元素的CollectionD、Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value 答案：A。List,Set继承了Collection接口，而Map是一个单独的接口。 [不定项选择题] ArrayLists和LinkedList的区别，下述说法正确的有？A、ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。B、对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。C、对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。D、ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。 答案：A B C D。不解释。 [不定项选择题] 关于volatile关键字，下列描述不正确的是？A、用volatile修饰的变量，每次更新对其他线程都是立即可见的。B、对volatile变量的操作是原子性的。C、对volatile变量的操作不会造成阻塞。D、不依赖其他锁机制，多线程环境下的计数器可用volatile实现。 答案：BD 。所谓volatile的措施，就是 每次从内存中取值，不从缓存中拿值。这就保证了用volatile修饰的共享变量，每次的更新对于其他线程都是可见的。 volatile保证了其他线程的立即可见性，就没有保证原子性。 由于有些时候对volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。 [不定项选择题] 下面有关java threadlocal说法正确的有？A、ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递B、线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收C、在Thread类中有一个Map，用于存储每一个线程的变量的副本。D、对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式 答案：A B C D。ThreadLocal类用于创建一个线程本地变量。线程内共享，线程间独立。在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。 关于sleep()和wait()，以下描述错误的一项是（ ）A、sleep是线程类（Thread）的方法，wait是Object类的方法；B、sleep不释放对象锁，wait放弃对象锁C、sleep暂停线程、但监控状态仍然保持，结束后会自动恢复D、wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态 答案：D，notity()和notifyAll()两个方法均可，应该进入就绪状态而不是运行状态。 有如下4条语句：()Integer i01=59;int i02=59;Integer i03=Integer.valueOf(59);Integer i04=new Integer(59); 以下输出结果为false的是:A、System.out.println(i01==i02);B、System.out.println(i01==i03);C、System.out.println(i03==i04);D、System.out.println(i02==i04); 答案：C。Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127并且大于等于-128时才可使用常量池，因为他们至占用一个字节(-128~127); i02 == i04时，i04自动拆箱，调用Integer的intValue()方法，返回是一个int类型。所以如果你测试如下代码 :1234567891011public static void main(String[] args) &#123; Integer a = 127; Integer b = 127; Integer c = 128; Integer d = 128; System.out.println(a == b); System.out.println(c == d);&#125; 结合自动封装、常量池以及Integer.valueOf方法就不难得出，答案时true和false； 假定str0,…,str4后序代码都是只读引用。Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）123456static String str0="0123456789";static String str1="0123456789";String str2=str1.substring(5);String str3=new String(str2);String str4=new String(str3.toCharArray());str0=null; A、5B、10C、15D、20 答案：C。substring实际是new，5字符；str3和4也都是new，每个5字符，分别都会创建新的对象；常量池是PermGen的。因此应该是一共15字符。Java堆区分为三个区：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）,年轻代由一个Eden区和俩个survivor区组成,新创建的对象都在年轻代的Eden区，经过一次JC收集后，存活下来的会被复制到survivor区(一个满了，就全部移动到另外一个大的中，但要保证其中一个survivor为空)，经过多次JC后，还存活的对象就被移到老年代了。 持久代就是经常说的方法区里面存放类信息，常量池。如下图所示： 以下哪些jvm的垃圾回收方式采用的是复制算法回收A、新生代串行收集器B、老年代串行收集器C、并行收集器D、新生代并行回收收集器E、老年代并行回收收集器F、cms收集器 答案：A D 。几种最基本的java回收算法： 标记-清除法：标记所有从根结点开始的可达对象，缺点是会造成内存空间不连续，不连续的内存空间的工作效率低于连续的内存空间，不容易分配内存。 复制算法：将内存空间分成两块，每次将正在使用的内存中存活对象复制到未使用的内存块中，之后清除正在使用的内存块。算法效率高，但是代价是系统内存折半。适用于新生代(存活对象少，垃圾对象多)。 标记－压缩算法：标记－清除的改进，清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清理边界所有空间既避免碎片产生，又不需要两块同样大小的内存快，性价比高。适用于老年代。 [不定项选择题] 下面有关java类加载器，说法正确的是？A、引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的B、扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。C、系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类D、tomcat为每个App创建一个Loader，里面保存着此WebApp的ClassLoader。需要加载WebApp下的类时，就取出ClassLoader来使用 答案：ABCD。JVM三种预定义类型类加载器,详见这篇文章: 启动（Bootstrap）类加载器：引导类装入器是用本地代码实现的类装入器，它负责将 /lib 下面的类库加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 标准扩展（Extension）类加载器：扩展类加载器是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader） 实现的。它负责将 &lt; Java_Runtime_Home &gt;/lib/ext 或者由系统变量 java.ext.dir 指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 系统（System）类加载器：系统类加载器是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。 以下代码的输出结果是？12345678910111213141516public class B&#123; public static B t1 = new B(); public static B t2 = new B(); &#123; System.out.println("构造块"); &#125; static &#123; System.out.println("静态块"); &#125; public static void main(String[] args) &#123; B t = new B(); &#125;&#125; A、静态块 构造块 构造块 构造块B、构造块 静态块 构造块 构造块C、构造块 构造块 静态块 构造块D、构造块 构造块 构造块 静态块 答案：C 。注意点 ： 每调用一次构造方法，则执行一次构造块；静态块只在类加载的时候加载一次；有多个静态变量或块时，按声明顺序加载。 有关下述Java代码描述正确的选项是__。12345678public class TestClass &#123; private static void testMethod()&#123; System.out.println("testMethod"); &#125; public static void main(String[] args) &#123; ((TestClass)null).testMethod(); &#125;&#125; A、编译不通过B、编译通过，运行异常，报NullPointerExceptionC、编译通过，运行异常，报IllegalArgumentExceptionD、编译通过，运行异常，报NoSuchMethodExceptionE、编译通过，运行异常，报ExceptionF、运行正常，输出testMethod 答案：F 。方法是static静态方法，直接使用”类.方法”即可，因为静态方法使用不依赖对象是否被创建。null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。 下面关于abstract关键字描述错误的是（）A、abstract关键字可以修饰类或方法B、final类的方法都不能是abstract，因为final类不能有子类C、abstract类不能实例化D、abstract类的子类必须实现其超类的所有abstract方法 答案：D 。抽象类不能被实例化，无法使用new关键字调用抽象类的构造器创建抽象类的实例，即使抽象类不包含抽象方法，也不能被实例化。 如下代码，执行test()函数后，屏幕打印结果为（）12345678910111213141516public class Test2&#123; public void add(Byte b) &#123; b = b++; &#125; public void test() &#123; Byte a = 127; Byte b = 127; add(++a); System.out.print(a + " "); add(b); System.out.print(b + ""); &#125;&#125; A、127 127B、128 127C、129 128D、以上都不对 答案：D 。Byte的首字母为大写，是类，看似是引用传递，但是在add函数内实现++操作，会自动拆包成byte值传递类型，所以add函数还是不能实现自增功能。也就是说add函数只是个摆设，没有任何作用。 Byte类型值大小为-128~127之间。 add(++a);这里++a会越界，a的值变为-128 add(b); 前面说了，add不起任何作用，b还是127。 问这个程序的输出结果。1234567891011121314151617181920212223242526272829package Wangyi;class Base&#123; public void method() &#123; System.out.println("Base"); &#125; &#125;class Son extends Base&#123; public void method() &#123; System.out.println("Son"); &#125; public void methodB() &#123; System.out.println("SonB"); &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Base base = new Son(); base.method(); base.methodB(); &#125;&#125; A、Base SonBB、Son SonBC、Base Son SonBD、编译不通过 答案：D 。这句new 了一个派生类，赋值给基类，所以编译器认为base对象就是Base类型的Base类中不存在methodB()方法，所以编译不通过。 检查程序，是否存在问题，如果存在指出问题所在，如果不存在，说明输出结果。1234567891011121314package algorithms.com.guan.javajicu; public class Inc &#123; public static void main(String[] args) &#123; Inc inc = new Inc(); int i = 0; inc.fermin(i); i= i ++; System.out.println(i); &#125; public void fermin(int i) &#123; i++; &#125; &#125; A、0B、1C、2D、3 答案：A 。顺序应该是：先计算表达式的值，得0，然后i加1，此时i=1，最后赋值，赋值是把表达式的值赋值，所以，i又变成0了。Java使用了中间缓存变量机制：123456789i=i++;等同于：temp=i；(等号右边的i)i=i+1; (等号右边的i)i=temp; (等号左边的i)而i=++i;则等同于：i=i+1;temp=i;i=temp;]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发中容易忽略的类、方法、接口]]></title>
    <url>%2F2017%2F03%2F29%2FAndroid%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E7%B1%BB%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[UI相关 android:drawableLeft、android:drawableTop、android:drawableRight、android:drawableBottom 可以设置显示图片的位置，一般我们需要一个LinearLayout + ImageView + TextView 才能实现的效果 ，TextView用这属性就能实现了。还可以用TextView.setTextView.setCompoundDrawablePadding代码设置TextView的各个位置的drawable padding。 TextView.setError() 在验证用户输入的时候很棒。 TextView.append()) 很有用的方法，用于为TextView添加显示内容。 Space Space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。 ViewStub 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。 Merge 此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。 android:clipChildren 和 android:clipToPadding clipToPadding就是说控件的绘制区域是否在padding里面的，true的情况下如果你设置了padding那么绘制的区域就往里 缩，clipChildren是指子控件是否超过padding区域，这两个属性默认是true的，所以在设置了padding情况下，默认滚动是在 padding内部的，要达到上面的效果主要把这两个属性设置了false那么这样子控件就能画到padding的区域了。使用场景如：ActionBar（透明）下显示Listview而第一项要在actionbar下。参见 android:clipToPadding和android:clipChildren。 android:weightSum (LinearLayout) 如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。 android:duplicateParentState (View) 此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。常见的使用场景是某些时候一个按钮很小，我们想要扩大其点击区域的时候通常会再给其包裹一层布局，将点击事件写到Parent上，这时候如果希望被包裹按钮的点击效果对应的Selector继续生效的话，这时候duplicateParentState就派上用场了。 android:fillViewport (ScrollView) 在这片文章中有详细介绍文章链接，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。 android:tileMode (BitmapDrawable) 可以指定图片使用重复填充的模式。 android:enterFadeDuration/android:exitFadeDuration (Drawables) 此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。 视图操作相关 AutoScrollHelper 在可滚动视图中长按边缘实现滚动，Android View.OnTouchListener 的子类。 ViewDragHelper ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，DrawerLayout就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的优秀文章。 ViewParent.requestDisallowInterceptTouchEvent() Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权。 View.generateViewId() 每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。 View类中的三个方法：callOnClick()，performClick()，performLongClick()，用于触发View的点击事件。 TouchSlop 系统所能识别出的被认为是最小的滑动距离，ViewConfiguration.get(context).getScaledTouchSlop()。 VelocityTracker 可用于 View 滑动事件速度跟踪。 系统相关 ActivityManager.getMemoryClass() 告诉你你的机器还有多少内存，在计算缓存大小的时候会比较有用。 ActivityManager.clearApplicationUserData() 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。 Activity.recreate () 强制让 Activity 重建。 Activity.onBackPressed() 很方便的管理back键的方法，有时候需要自己控制返回键的事件的时候，可以重写一下。比如加入 “点两下back键退出” 功能。 Context.getCacheDir() 获取缓存数据文件夹的路径，这个路径通常在SD卡上/data/您的应用程序包名/cache/ 下面。测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空。 Context.getExternalFilesDir() 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。 Environment.getExternalStoragePublicDirectory() 还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。 ActivityLifecycleCallbacks 接口，用于在Application类中监听各Activity的状态变化。 RemoteCallbackList列表 ,在Service中可以监听client的进程是否退出，并自动删除。 Context.createConfigurationContext() 自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。 PackageManager.checkSignatures () 如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。 Fragment 的 setUserVisibleHint 方法，可实现 fragment 对用户可见时才加载资源（延迟加载）, 在ViewPager中切换时特别有用。 DialogFragment.setShowsDialog() 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。 FragmentManager.enableDebugLogging () 在需要观察 Fragment 状态的时候会有帮助。 LocalBroadcastManager 这个会比全局的 broadcast 更加安全，简单，快速。像 otto 这样的 Event buses 机制对你的应用场景更加有用。 -nodpi 在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。 Resources类中的getIdentifier(name, defType, defPackage)方法，根据资源名称获取其ID，做UI时经常用到。 工具类 TextUtils.isEmpty() 简单的工具类,用于检测是否为空。 DatabaseUtils 一个包含各种数据库操作的使用工具。 ThumbnailUtils 帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。 DateUtils.formatDateTime() 用来进行区域格式化工作，输出格式化和本地化的时间或者日期。 PhoneNumberUtils.formatNumber () 顾名思义，这是对数字进行格式化操作的时候用的。 Linkify.addLinks() 在Text上添加链接。很实用。 UrlQuerySanitizer 使用这个工具可以方便对 URL 进行检查。 Formatter.formatFileSize() 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB，G，KB之类的字符串。 集合类 ArrayMap，比 HashMap 更高的内存效率，但比 HashMap 慢，不适合有大量数据的场景。 SparseArray Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。 Arrays类中的一系列关于数组操作的工具方法：binarySearch()，asList()，equals()，sort()，toString()，copyOfRange()等； Collections类中的一系列关于集合操作的工具方法：sort()，reverse()等； 常量类 Build.VERSION_CODES 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性。 Build.PRODUCT 可以获取手机的项目名 BuildConfig 这个类声明了 DEBUG模式、包名、BUILD_TYPE、FLAVOR、VERSION_CODE、VERSION_NAME 等，在代码中可以直接使用，不用去检测apk信息。 参考 Android开发中，有哪些让你觉得相见恨晚的方法、类或接口？ Android Tips Round-Up, Part 1 Android Tips Round-Up, Part 2 Android Tips Round-Up, Part 3 Android Tips Round-Up, Part 4 Android Tips Round-Up, Part 5]]></content>
      <categories>
        <category>干货</category>
      </categories>
      <tags>
        <tag>程序优化</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Kotlin实现的三种 RxBus]]></title>
    <url>%2F2017%2F03%2F22%2F%E5%9F%BA%E4%BA%8EKotlin%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%89%E7%A7%8D-RxBus%2F</url>
    <content type="text"><![CDATA[RxBus 是 EventBus 在RxJava 的替代品 ，而在RxJava 中只需要短短几行代码就能实现。RxJava1 与 RxJava2 有些微不同，具体可以参考 What’s different in 2.0 。下面总结用Kotlin 实现的不同场景的 RxBus : 没有背压处理（Backpressure）的 Rxbus 有背压处理的 RxBus 有异常处理的 Rxbus （订阅者处理事件出现异常也能继续收到事件） 没有背压处理（Backpressure）的 Rxbus在RxJava2里，引入了Flowable这个类来处理Backpressure，而Observable不包含Backpressure 处理。123456789101112131415object RxBus &#123; private val mBus: Subject&lt;Any&gt; = PublishSubject.create() fun &lt;T&gt; toObservable(clzz: Class&lt;T&gt;): Observable&lt;T&gt; = mBus.ofType(clzz) fun toObservable(): Observable&lt;Any&gt; = mBus fun post(obj: Any) &#123; mBus.onNext(obj) &#125; fun hasObservers(): Boolean &#123; return mBus.hasObservers() &#125;&#125; 但是在调用toObservable(clzz: Class&lt;T&gt;)的时候，不要简单使用 XXX.class ，因为这样不符合Kotlin的语法，正确的的调用方式是 :1RxBus.toObservable(String::class.java).subscribe( ... ) 有背压处理的 RxBus12345678910111213141516171819object RxBus &#123; private val mBus: FlowableProcessor&lt;Any&gt; = PublishProcessor.create() fun &lt;T&gt; toFlowable(tClass: Class&lt;T&gt;): Flowable&lt;T&gt; &#123; return mBus.ofType(tClass) &#125; fun toFlowable(): Flowable&lt;Any&gt; &#123; return mBus &#125; fun post(obj: Any) &#123; mBus.onNext(obj) &#125; fun hasSubscribers(): Boolean &#123; return mBus.hasSubscribers() &#125;&#125; 有异常处理的 Rxbus -基于 RxRelay RxRelay 是既是Observable也是Consumer的RxJava 类型。123456789101112131415object RxBus3 &#123; private val mBus: PublishRelay&lt;Any&gt; = PublishRelay.create() fun &lt;T&gt; toObservable(clzz: Class&lt;T&gt;): Observable&lt;T&gt; = mBus.ofType(clzz) fun toObservable(): Observable&lt;Any&gt; = mBus fun post(obj: Any) &#123; mBus.accept(obj) &#125; fun hasObservers(): Boolean &#123; return mBus.hasObservers() &#125;&#125; 关于RxRelay与Subject 的区别，网上一般说”RxRelay 即使出现异常也不会终止订阅关系” , 一开始看到这句话，有点蒙，因为根据我的实际验证，订阅者有异常时，这个订阅会自动取消，也不会影响其它订阅者，这个效果 RxRelay 与 Subject 是一样的。而它们真正的区别是 Subject 是Observable也是Observer，所以它可以发送 onComplete 、onError ,这样，会取消订阅所有的订阅者，订阅有被动取消订阅的意思。 RxRelay 是Observable也是Consumer , 所以RxRelay 不能发送 onComplete 、onError , 那也就不用担心被中断了。 参考 RxJava 2 版本的 Rxbus 基于 RxJava 2 和 RxRelay 实现 RxBus]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 使用Kotlin的一些技巧]]></title>
    <url>%2F2017%2F03%2F02%2FAndroid-%E4%BD%BF%E7%94%A8Kotlin%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[打印Log 1Log.d(TAG , "print i = $i , j = $j , len = $&#123;str.length&#125; ") 设置 listeners 1myButton.setOnClickListener &#123; navigateToDetail() &#125; for 语句中的范围在Java 中 ： 1234567for (int i = 1; i &lt;= 10 ; i++) &#123; &#125;for (int i = 1; i &lt; 10 ; i++) &#123; &#125;for (int i = 10; i &gt;= 0 ; i--) &#123; &#125;for (int i = 1; i &lt;= 10 ; i+=2) &#123; &#125;for (int i = 10; i &gt;= 0 ; i-=2) &#123; &#125;for (String item : collection) &#123; &#125;for (Map.Entry&lt;String, String&gt; entry: map.entrySet()) &#123; &#125; 在Kotlin 中 ：1234567for (i in 1..10) &#123; &#125;for (i in 1 until 10) &#123; &#125;for (i in 10 downTo 0) &#123; &#125;for (i in 1..10 step 2) &#123; &#125;for (i in 10 downTo 1 step 2) &#123; &#125;for (item in collection) &#123; &#125;for ((key, value) in map) &#123; &#125; 参数个数不定的函数在Java 中我们可以定义参数个数不固定的函数 :1void doSomething(int... numbers) &#123; &#125; 而在Kotlin中我们要用 vararg 关键字 ， 使用上是一样的 ：1fun doSomething(vararg numbers: Int) &#123; &#125; Handler、Thread可以写得更简洁 1234view.postDelayed(&#123; doWhatever() &#125;, 200)Thread().run &#123; // Running in a thread &#125; 省去一些不必要的代码一般在java中我们经常要判断一个类对象是否为空，而在kotlin 中，对象一般是非空的，除非你定义时加了?号，这样在代码中就不必要经常加空判断了。 12val str : String = null //报错val str : String? = null //正常 而kotlin对空的判断也很简洁 :12val nullStr : String? = nullval size : Int = nullStr?.length ?: 0 // 如果nullStr为空就返回0 解析布局我们以前用java在inflate一个布局时，一般是这样写的 :1LayoutInflater.from(parent.getContext()).inflate(R.id.my_layout, parent, false); 在Kotlin中，我们可以定义扩展函数 ：123fun ViewGroup.inflate(@LayoutRes layoutRes: Int, attachToRoot: Boolean = false): View &#123; return LayoutInflater.from(context).inflate(layoutRes, this, attachToRoot)&#125; 这样在代码中我们就可以这样使用它 ：12parent.inflate(R.layout.my_layout)parent.inflate(R.layout.my_layout, true) ImageView 加载网络图片我们仍然为ImageView 定义一个扩展函数，使用你的加载图片的库，比如Picasso：123fun ImageView.loadUrl(url: String) &#123; Picasso.with(context).load(url).into(this)&#125; 这样在代码中我们就可以这样使用它 ：1imageView.loadUrl("http://..../") 处理Options Menu在Java时，在处理多个选择时我们一般用 switch，而在Kotlin中，我们可以用when 语句 ：1234567override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) &#123; R.id.action_settings -&gt; consume &#123; navigateToSettings() &#125; R.id.nav_camera -&gt; drawer.consume &#123; navigateToCamera() &#125; R.id.nav_gallery -&gt; drawer.consume &#123; loadGallery() &#125; R.id.nav_slideshow -&gt; drawer.consume &#123; loadSlideshow() &#125; else -&gt; super.onOptionsItemSelected(item)&#125; 其中consume 函数是一个 inline 函数 ：1234inline fun consume(f: () -&gt; Unit): Boolean &#123; f() return true&#125; 初始化控件在Java时，我们一般要在setContentView之后再调用findViewByID初始化控件，而在Kotlin中可以用lazy懒加载 ： 12345678override val textView by lazy &#123; findViewById(R.id.sample_text) as TextView &#125;override val dataBase by lazy &#123; DataBase(this) &#125;override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_detail) textView.setText(R.string.text) dataBase.loadWhatever()&#125; 处理集合类Kotlin中的集合类提供了很多处理函数，方便我们调用，比如 filter、sort、map. 1234return parsedContacts.filter &#123; it.name != null &amp;&amp; it.image != null &#125; .sortedBy &#123; it.name &#125; .map &#123; Contact(it.id, it.name!!, it.image!!) ]&#125; 定义 数据类一般在Java定义数据类时，getters, setters, toString(), equals() … 都需要我们自己编写，在Kotlin就不用这么麻烦了。 1data class Person(val name: String, val surname: String, val age: Int) 定义常量 12345678910object DefaultValues &#123; val FILES_TO_DOWNLOAD = 100&#125;class DefaultValues private constructor() &#123; companion object &#123; val FILES_TO_DOWNLOAD = 100 &#125;&#125;// 只能在 top levelconst val DEFAULT_FILES_TO_DOWNLOAD = 100 定义单例 12345678910class Singleton private constructor() &#123; private object Holder &#123; val INSTANCE = Singleton() &#125; companion object &#123; val instance: Singleton by lazy &#123; Holder.INSTANCE &#125; &#125;&#125; 参考Kotlin awesome tricks for Androidkotlin vs java]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 RxJava2 backpressure的一些理解]]></title>
    <url>%2F2017%2F02%2F18%2F%E5%85%B3%E4%BA%8E-RxJava2-backpressure%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[RxJava2 中的背压在RxJava2里，引入了Flowable这个类来处理backpressure，而Observable不包含backpressure处理。Flowable的三种Backpressure策略： BackpressureStrategy.BUFFERonBackpressureBuffer是不丢弃数据的处理方式。把上游收到的全部缓存下来，等下游来请求再发给下游。相当于一个水库。但上游太快，水库（buffer）就会溢出。 BackpressureStrategy.DROP 与 BackpressureStrategy.LATESTDrop 和Latest 类似，都会丢弃数据，下游通过request请求产生令牌给上游，上游接收到多少令牌，就发送多少，当令牌为0的时候，上游开始丢弃数据。区别在于，drop直接丢弃数据不缓存数据。而latest缓存最新的一条数据，当上游收到令牌，就把缓存的上一条“最新”数据发送给下游。 例如 ：123456789Flowable&lt;Integer&gt; flowable = Flowable.create((FlowableOnSubscribe&lt;Integer&gt;) e -&gt; &#123; for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123; Log.d(TAG, "onNext : " + i); e.onNext(i); Thread.sleep(10); &#125; &#125;, BackpressureStrategy.DROP).subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); Flowable以10毫秒一次派发数据，注意我们让Flowable和订阅者运行在不同的线程，这样才能看出生产与消费在不同效率下时的差异性，如果Flowable和订阅者在同一线程，背压是没什么意义的。假设订阅他们的方法都是:12345678910111213141516171819202122Subscription mSubscription;flowable.subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription subscription) &#123; mSubscription = subscription; &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, "onNext: " + integer); &#125; @Override public void onError(Throwable throwable) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); 我们在onSubscribe中保存了Subscription ，以后 方便我们可以在任何时候request 数据。我们添加一个按钮，以实现手动request数据 ，代码如下：123if(mSubscription != null) &#123; mSubscription.request(64);&#125; 我们一开始request 64个数据，我们启动Flowable后，隔一段时间才点击request , log打印 0 ~ 63 ：123456D/SimpleExampleActivity: onNext: 0D/SimpleExampleActivity: onNext: 1D/SimpleExampleActivity: onNext: 2...D/SimpleExampleActivity: onNext: 63D/SimpleExampleActivity: onNext: 64 隔一段时间第二次点击request , log打印 64~ 127 ：123456D/SimpleExampleActivity: onNext: 64D/SimpleExampleActivity: onNext: 65D/SimpleExampleActivity: onNext: 66...D/SimpleExampleActivity: onNext: 126D/SimpleExampleActivity: onNext: 127 隔一段时间第三次点击request , log打印 1243~ 1306：1234567D/SimpleExampleActivity: onNext: 1243D/SimpleExampleActivity: onNext: 1244D/SimpleExampleActivity: onNext: 1245...D/SimpleExampleActivity: onNext: 1304D/SimpleExampleActivity: onNext: 1305D/SimpleExampleActivity: onNext: 1306 我们使用是BackpressureStrategy.DROP ， 与就是 直接丢弃数据不缓存数据 。可是我们一开始隔了点时间再request时，还是打印从 0 ~ 127 ， 这说明 Flowable 本身就会存储缓存 128 个数据，超过128个后执行我们的策略，也就是丢弃。所以 1243~ 1306 其实是我们在第二次点击后，重新缓存的128数据。如果我们换成 BackpressureStrategy.BUFFER ， 那么不管你点击多少次，数据都是连续的，因为 BackpressureStrategy.BUFFER 策略会把数据一直放到内存中，直到发生OutOfMemoryError。我们现在修改request 的数目 ，改成 每次 request 96 个 ， 代码如下 ：123if(mSubscription != null) &#123; mSubscription.request(96);&#125; 第一次点击request , log打印 0 ~ 95 , 没什么问题123456D/SimpleExampleActivity: onNext: 0D/SimpleExampleActivity: onNext: 1D/SimpleExampleActivity: onNext: 2...D/SimpleExampleActivity: onNext: 94D/SimpleExampleActivity: onNext: 95 隔一段时间第二次点击request , log打印 96 ~ 127 , 188 ~ 251 :1234567891011D/SimpleExampleActivity: onNext: 96D/SimpleExampleActivity: onNext: 97D/SimpleExampleActivity: onNext: 98...D/SimpleExampleActivity: onNext: 126D/SimpleExampleActivity: onNext: 127D/SimpleExampleActivity: onNext: 188D/SimpleExampleActivity: onNext: 189...D/SimpleExampleActivity: onNext: 250D/SimpleExampleActivity: onNext: 251 隔一段时间第三次点击request , log打印 252 ~ 283 , 650 ~ 713:12345678910D/SimpleExampleActivity: onNext: 252D/SimpleExampleActivity: onNext: 253...D/SimpleExampleActivity: onNext: 282D/SimpleExampleActivity: onNext: 283D/SimpleExampleActivity: onNext: 650D/SimpleExampleActivity: onNext: 651...D/SimpleExampleActivity: onNext: 712D/SimpleExampleActivity: onNext: 713 我们可以看到第二次、第三次时打印的数据出现了中断的情况。我们知道Flowable 默认会缓存 127个数据，那么第一次点击之后应该剩下 128 - 96 = 32个 ， 所以第二次首先打印 96 ~ 127 ， 之后再打印 188 ~ 251 64个数据。第三次又打印了 252 ~ 283 32个数据。第二次打印中断之后打印的 64个数据 加上 第三次打印中断前打印的 32个，刚好是 96个数据，也就是打印中断的时间点的数据刚好是96个。这个96就是Flowable 重新去拉取缓存的限制，这是在源码上设定的，就是说首先缓存了 128个数据之后，被消费了96个数据时才会重新缓存。所以在第二次时，从127后就打印了 188，因为这个188是在第一次点击之后就重新缓存了。 总结Flowable 有三种Backpressure策略，分别是BackpressureStrategy.BUFFER、BackpressureStrategy.DROP 和 BackpressureStrategy.LATEST。默认会缓存 127个数据，被消费了96个数据后才会重新缓存。 参考探索专为 Android 而设计的 RxJava 2RxJava2 vs RxJava1]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Dagger2中的@Singleton的理解]]></title>
    <url>%2F2017%2F01%2F16%2F%E5%85%B3%E4%BA%8EDagger2%E4%B8%AD%E7%9A%84-Singleton%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Dagger被Square开发，项目地址：square.github.io/dagger使用了一段时间的Dagger2之后，对Dagger2有些小小的认识。 使用Dagger依赖注入的好处 增加开发效率、省去重复的简单体力劳动 更好的管理类实例 app中的组件不需要知道有关实例创建和生命周期的任何事情，这些由我们的依赖注入框架管理的。 解耦一个类的创建是非常可能充斥在app的多个类中的，假如该类的构造函数发生变化，那这些涉及到的类都得进行修改。对MVP架构来说，可以进一步降低modle-view-presenter之间的耦合度。 Dagger各模块的联系 @Module用于标记提供依赖的类，Dagger就知道在那里需要构造对象了。@Provides标记Module中返回依赖的方法。 @Inject注解。作为JSR-330标准的一部分，标记那些依赖注入框架提供的依赖。Dagger2中，有3种不同的方式提供依赖： 构造器注入 域注入 方法注入 @Component : 这个注解用于构建接口，该接口把所有封装在一起。这里，我们定义需要依赖的模块(或组件)。这里定义了那些依赖可注入，我们的组件可以注入哪里。@Component是连接@Module和@Inject的桥梁。 利用@Singleton构建单例一般需要创建单例时，我们需要在 Module 和蔼Component 中都添加 @Singleton 注解1234567891011121314@Modulepublic class PersonModule &#123; @Provides @Singleton public Person providePerson() &#123; return new Person(); &#125;&#125;@Singleton@Component(modules = PersonModule.class)public interface MainComponent &#123; void inject(MainActivity activity);&#125; 然后在 Application 类中创建 MainComponent 对象 ，这样在其它Activity中就可以通过获取Application的对象来inject 自己，这样创建出来的Person类就是一个单例子。1234567891011121314151617// Application MainComponent mMainComponent; SubComponent mSubComponent; @Override public void onCreate() &#123; super.onCreate(); &#125; public MainComponent getMainComponent() &#123; if(mMainComponent == null) mMainComponent = DaggerMainComponent.builder().build(); return mMainComponent; &#125;// Activity((App)getApplication()).getMainComponent().inject(this); 但是如果你不在Application中创建 MainComponent ，也就是在每个Activity都创建自己的MainComponent时，创建出来的Person类是不同的对象 ，说明在不同的MainComponent对象的时候，退即使使用了@Singleton 注解 ，最后创建的也不是单例。为了查明这个原因 ，我们查看Singleton的源码 ：1234@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; 它本身是一个Scope , 也没有特别的代码。那是不是我们自定义一个Scpoe也可以实现Singleton的效果呢，答案是肯定的。1234// 自定义的Scope @Scope@Retention(RetentionPolicy.RUNTIME)public @interface UserScope &#123;&#125; 自定义的Scope 使用方法与Singleton一样，把@Singleton换成@UserScope就可以了。通过多次验证的结果证明 : 用同一个component ，并声明同一个Scope ，创建出来的是同一个对象。 另外在看其它博客文章的时候，你会经常看到 @ActivityScope 可以声明一个Activity生命周期的对象 ，@ApplicationScope 可以声明一个Application生命周期的对象 ， 难道这些Scope这么神？ 定义一个名字就可以控制对象的生命周期了？ 其实这和 @Singleton一样的，都是代码是否通过同一个 component 对象来控制的。比如 @ActivityScope 定义的对象 ，其在Activity创建了component对象 ，那这个component对象肯定在这个Activity的生命周期内啊，依赖创建出来的对象也肯定是这个Activity啊。还有@ApplicationScope 中的component 对象是在 Application中的，那依赖创建出来的对象的生命周期也肯定是和 @Singleton的一样的，单例的生命周期不就是整个 Application 吗。 总结所以 Scope 的定义的名字不是控制对象生命周期的关键，取名 ActivityScope 、ApplicationScope、Singleton 只是让我们更好理解，提高代码可读性，真正控制对象生命周期的是 Component对象 。 参考 最简单的Dagger2入门教程 解锁Dagger2使用姿势（二） 之带你理解@Scope]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Tint属性优化Selector]]></title>
    <url>%2F2017%2F01%2F05%2F%E5%88%A9%E7%94%A8Tint%E5%B1%9E%E6%80%A7%E4%BC%98%E5%8C%96Selector%2F</url>
    <content type="text"><![CDATA[关于Selector的使用Selector中文的意思选择器，在Android中常常用来作组件的背景，这样做的好处是省去了用代码控制实现组件在不同状态下不同的背景颜色或图片的变换。使用十分方便。Selector就是状态列表（StateList）， 它分为两种，一种Color-Selector 和Drawable-Selector。一般使用语法如下：1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize=["true" | "false"]//drawable的大小是否当中状态变化，true表示是变化，false表示不变换，默认为false android:dither=["true" | "false"]//当位图与屏幕的像素配置不一样时(例如，一个ARGB为8888的位图与RGB为555的屏幕)会自行递色(dither)。设置为false时不可递色。默认true android:variablePadding=["true" | "false"] &gt;//内边距是否变化，默认false &lt;item android:drawable="@[package:]drawable/drawable_resource"//图片资源 android:state_pressed=["true" | "false"]//是否触摸 android:state_focused=["true" | "false"]//是否获取到焦点 android:state_hovered=["true" | "false"]//光标是否经过 android:state_selected=["true" | "false"]//是否选中 android:state_checkable=["true" | "false"]//是否可勾选 android:state_checked=["true" | "false"]//是否勾选 android:state_enabled=["true" | "false"]//是否可用 android:state_activated=["true" | "false"]//是否激活 android:state_window_focused=["true" | "false"] /&gt;//所在窗口是否获取焦点&lt;/selector&gt; 比如我们创建一个 DrawableSelector , 在/res/drawable/文件夹下新建btn_seletor.xml :12345&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/ic_btn_back_pressed" /&gt; &lt;item android:drawable="@drawable/ic_btn_back_normal" /&gt;&lt;/selector&gt; 调用时直接设置在android:background属性上 :12345&lt;Button android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:background="@drawable/btn_seletor"/&gt; 编译之后就能看到 点击按钮时，按钮图标就会变。 我们会发现，一般实现Selector的方法，需要以下两点 : 需要两张大小一样，表示不同状态效果的图片 创建一个selector的xml文件 但是两张状态效果一样的图片，除了颜色，其它都是一样的，我们能不能只用一张图片来实现，在代码里修改图片的颜色呢？ 答案当然是可以的，那就是利用android:tint属性。 如何使用tint 属性android:tint 是ImageView 特有的属性，所以我们用ImageView 来实现上面的例子，首先创建一个btn_single_seletor.xml, 注意使用的是同一张图片ic_btn_back_normal:12345&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/ic_btn_back_normal" /&gt; &lt;item android:drawable="@drawable/ic_btn_back_normal" /&gt;&lt;/selector&gt; 接着再创建image_color.xml 的 ColorDrawable , 并放在 /res/color/文件夹下 :12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true" android:color="#fac300" /&gt; &lt;item android:color="#00000000" /&gt;&lt;/selector&gt; 最后设置到 ImageView 上:1234567&lt;ImageView android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:tint="@color/image_color" android:src="@drawable/btn_single_seletor" android:clickable="true"/&gt; 编译之后就能看到 点击按钮时，效果与上面的例子是一样的。也许你会注意到在image_color.xml 中我们设置的颜色是#00000000 , 这是为了让图片不着色。如果我们一定要用Button来实现呢，但是Button没有android:src和android:tint属性怎么办？ 虽然在普通view可以设置这两个属性，但是没有效果。其实我们可以用android:background、android:backgroundTint属性，我们添加一个Button 如下 ：123456&lt;Button android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:background="@drawable/btn_single_seletor" android:backgroundTint="@color/image_color"/&gt; 编译安装之后你会发现，在普通状态时，按钮的图片是透明的，这和我们设置的普通状态下 tint color = #00000000”有关 , 不知道这是不是android的 bug ,为什么在src + tint 时就可以，在 background + backgroundTint 时就不行，知道答案的可以交流一下。 更优雅地使用 tint 属性在上面的例子中，我们设置了两个属性 ，其实我们可以只设置 android:background 或 android:src , 而不用设置 tint , 我们再添加 bitmap.xml :1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@drawable/ic_btn_back_normal" android:tint="#fac300" /&gt; 再新增 btn_notint_seletor.xml ， 添加 bitmap.xml :12345&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true" android:drawable="@drawable/bitmap" /&gt; &lt;item android:drawable="@drawable/ic_btn_back_normal" /&gt;&lt;/selector&gt; 最后设置到 ImageView 与 Button 上 ，去掉 android:tint 、android:backgroundTint属性:123456789101112&lt;ImageView android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:src="@drawable/btn_notint_seletor" android:clickable="true"/&gt;&lt;Button android:layout_width="@dimen/image_size" android:layout_height="@dimen/image_size" android:layout_margin="5dp" android:background="@drawable/btn_notint_seletor"/&gt; 编译安装之后就能看到，效果与上面的例子是一样的。虽然添加多了一个bitmap.xml文件，但是我们免去了设置tint属性，不过上面的代码还可以再优化，就是去掉bitmap.xml , 我们在 btn_notint_seletor.xml 的基础上修改成 btn_notint_final_seletor.xml 文件：1234567&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;bitmap android:src="@drawable/ic_btn_back_normal" android:tint="#fac300" /&gt; &lt;/item&gt; &lt;item android:drawable="@drawable/ic_btn_back_normal" /&gt;&lt;/selector&gt; 重新设置成btn_notint_seletor之后，效果是一样的，而且代码更加简洁。这就是设置selector的最简洁的方式，我们只使用了一张图片，一个selector文件 就实现了效果。 使用 RotateDrawable 实现更多效果我们在实际开发中可能会经常碰到，左右翻页，上下翻页的情形，就是我们需要两张左右对称的图片，来实现左右箭头。如果加上点击效果的selector，那就需要4张图片了。如果我们用上面的方法，那也至少需要两张图片，那我们能不能在代码上实现图片的旋转呢，那就是使用 RotateDrawable 。 关于 RotateDrawable 的用法，可以参考这篇文章 ，我们创建一个btn_rotate_final_seletor.xml ：1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;rotate android:visible="true" android:fromDegrees="-180" android:pivotX="50%" android:pivotY="50%"&gt; &lt;bitmap android:src="@drawable/ic_btn_back_normal" android:tint="#fac300" /&gt; &lt;/rotate&gt; &lt;/item&gt; &lt;item&gt; &lt;rotate android:drawable="@drawable/ic_btn_back_normal" android:visible="true" android:fromDegrees="-180" android:pivotX="50%" android:pivotY="50%"&gt; &lt;/rotate&gt; &lt;/item&gt;&lt;/selector&gt; 重新设置成 Button的background之后，编译安装，效果实现了，而且还是左右对称的两个按钮。是不是觉得很简洁，我们只用了一张图片就实现了左右箭头的两个按钮。看看最终效果 : 总结使用这种方式来实现Selector ，不仅让代码更加简洁，而且省去了很多图片，减少了APK的大小。如果按平常的思路,在实现左右箭头的这个例子我们需要四张图片，平时一张图片至少也要几K 到 几十K，而现在只需要一张，减少了四分之三的大小。而且在后期中，如果要更改效果，我们只需要修改一下颜色值就可以了，炒鸡方便。 DemoDEMO 已经放在Github上了，有需要的可以去下载。https://github.com/zhooker/AndroidSelectorDemo 参考 Android中selector的使用 安卓着色器(tint)使用实践 Android Drawable Resource学习（十一）、RotateDrawable]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>程序优化</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JavaScript基础] 闭包]]></title>
    <url>%2F2016%2F11%2F05%2FJavaScript%E5%9F%BA%E7%A1%80-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。总而言之，闭包是指有权访问另一个函数作用域中的变量的函数。 下面就是我的学习笔记，对于Javascript初学者应该是很有用的。 一、变量的作用域要理解闭包，首先必须理解Javascript特殊的变量作用域。变量的作用域无非就是两种：全局变量和局部变量。Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。12345 var n=999; function f1()&#123; alert(n); &#125; f1(); // 999 另一方面，在函数外部自然无法读取函数内的局部变量。1234 function f1()&#123; var n=999; &#125; alert(n); // error 这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！12345 function f1()&#123; n=999; &#125; f1(); alert(n); // 999 二、如何从外部读取局部变量？出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。123456 function f1()&#123; var n=999; function f2()&#123; alert(n); // 999 &#125; &#125; 在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！123456789 function f1()&#123; var n=999; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 三、闭包的概念上一节代码中的f2函数，就是闭包。各种专业文献上的”闭包”（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 四、闭包的用途闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。123456789101112 function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 五、使用闭包的注意点1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除（用delete），或主动设置引用为null。 2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JavaScript基础] JavaScript中的判断]]></title>
    <url>%2F2016%2F10%2F25%2FJavaScript%E5%9F%BA%E7%A1%80-JavaScript%E4%B8%AD%E7%9A%84%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[1. == 与 === 的区别== (equality 等同)两边值类型不同的时候，要先进行类型转换，再比较。=== (identity 恒等)不做类型转换，类型不同的一定不等。 “===”严格运算符的运算规则(1)不同类型值 : 如果两个值的类型不同，直接返回false。 (2)同一类的原始类型值 : 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。 (3)同一类的复合类型值 : 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。 (4)undefined和null : undefined 和 null 与自身严格相等,它们互相比较时结果为false , 这是与==不同的地方。 (5) NaN ：NaN与其它符号对比都返回false,判断两个NaN时返回的是false，所以只能用isNaN或Object.is()来判断 12null === null //trueundefined === undefined //true 当然，严格相等运算符 === 也不会对操作数进行类型转换，但是它会把 -0 和 +0 这两个数值视为相同的，还会把两个 NaN 看成是不相等的 “==”严格运算符的运算规则“==”相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下： (1)原始类型的值 : 原始类型的数据会转换成数值类型再进行比较。字符串和布尔值都会转换成数值。基本类型的值转换成布尔型时的规则：|数据类型| 转换成true的取值| 转换成false的取值||:-:|:-:|:-:|Undefined| 无| undefined|Boolean| true| false|Object| 非null时都为true| nullNumber| 非0和NaN时都为true| 0和NaNString|非空字符串| “”(空字符串) (2)对象与原始类型值比较 : 对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。 (3)undefined和null : undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。 (4)相等运算符的缺点 : 相等运算符隐藏的类型转换，会带来一些违反直觉的结果。 (5) NaN ：NaN与其它符号对比都返回false,判断两个NaN时返回的是false，所以只能用isNaN或Object.is()来判断 2. Object.is()用一个表达式来检查当前选择的元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。如果没有元素符合，或者表达式无效，都返回’false’。 Object.is() 会在下面这些情况下认为两个值是相同的： 两个值都是 undefined 两个值都是 null 两个值都是 true 或者都是 false 两个值是由相同个数的字符按照相同的顺序组成的字符串 两个值指向同一个对象 两个值都是数字并且 都是正零 +0 都是负零 -0 都是 NaN 都是除零和 NaN 外的其它同一个数字 Object.is() 与 === 的区别 ： Object.is()对比两个NaN时返回true, Object.is()判断+0 -0时返回false , 而===则相反。 3. 三个判断符号之间的区别 4.例子：12345678910111213141516171819202122232425262728293031323334353637383940414243&apos;&apos; == &apos;0&apos; // false0 == &apos;&apos; // true0 == &apos;0&apos; // truefalse == &apos;false&apos; // falsefalse == &apos;0&apos; // truefalse == undefined // falsefalse == null // falsenull == undefined // true&apos; \t\r\n &apos; == 0 // true这就是为什么建议尽量不要使用相等运算符。var a = undefined;if(!a)&#123; console.log(&quot;1&quot;); //1&#125;var a = undefined;if(a == null)&#123; console.log(&quot;1&quot;); //1&#125;var a = undefined;if(a === null)&#123; console.log(&quot;1&quot;); //无输出&#125;Object.is(&apos;foo&apos;, &apos;foo&apos;); // trueObject.is(window, window); // trueObject.is(&apos;foo&apos;, &apos;bar&apos;); // falseObject.is([], []); // falsevar test = &#123; a: 1 &#125;;Object.is(test, test); // trueObject.is(null, null); // true// 特例Object.is(0, -0); // falseObject.is(-0, -0); // trueObject.is(NaN, 0/0); // true]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JavaScript生成Loading效果]]></title>
    <url>%2F2016%2F10%2F20%2F%E7%94%A8JavaScript%E7%94%9F%E6%88%90Loading%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[一个简单的loading效果，用四个符号(-、\、|、/) 来模拟一个不断旋转的小东东，以提示用户当前正在载入中，ArcLive 上为玩家建立连线时便是这样显示的，呵呵。 1234567891011121314&lt;span id="loadin"&gt;-&lt;/span&gt;&lt;script type="text/javascript"&gt;function easy_loading(id) &#123; var symbol = ['-', '\\', '|', '/'], elem = document.getElementById(id), i = 0; (function __func() &#123; elem.innerHTML = symbol[i++ % 4]; setTimeout(__func, 200); &#125;)();&#125;easy_loading('loadin');&lt;/script&gt; 为了避免可能出现的阻塞浏览器线程的情况，这里用setTimeout 代替了setInterval。setTimeout()的使用方法 setTimeout()的使用方法setTimeout (表达式，延时时间)、setTimeout(表达式，交互时间)，延时时间/交互时间是以豪秒为单位的(1000ms=1s)。 setTimeout 在执行时，是在载入后延迟指定时间后，去执行一次表达式，仅执行一次。setTimeout 在执行时，它从载入后，每隔指定的时间就执行一次表达式。 基本用法 ：123456789101112131415//执行一段代码：var i=0;setTimeout("i+=1;alert(i)",1000);//执行一个函数：var i=0;setTimeout(function()&#123;i+=1;alert(i);&#125;,1000);//下面再来一个执行函数的：var i=0; function test()&#123; i+=1; alert(i); &#125; setTimeout("test()",1000); 用setTimeout实现setInterval的功能思路很简单，就是在一个函数中调用不停执行自己，有点像递归。12345678var i=0; function xilou()&#123; i+=1; if(i&gt;10)&#123;alert(i);return;&#125; setTimeout("xilou()",1000); //用这个也可以 //setTimeout(xilou,1000); &#125;]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript渐变效果的实现]]></title>
    <url>%2F2016%2F10%2F12%2FJavaScript%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 clearInterval() 方法可取消由 setInterval() 设置的 timeout。参数必须是由 setInterval() 返回的 ID 值。 效果： 当鼠标移上去透明度渐渐增加，鼠标移出，透明度渐渐减小。 关键代码：123456var speed = 0;if(target&gt;obj.alpha)&#123; speed = 5;&#125;else&#123; speed = -5;&#125; 根据目标值和当时值的对比，来决定是正向还是负向速度。12345678910for(i=0; i &lt; runs_li.length; i++)&#123; runs_li[i].timer = null; runs_li[i].alpha = 30; runs_li[i].onmouseover = function()&#123; startrun(this,100); &#125; runs_li[i].onmouseout = function()&#123; startrun(this,30); &#125;&#125; 给每一个元素加上各自的透明度值，各自的透明度变化分开。 全部代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt;#runs&#123;width:300px; margin:10px auto;&#125;#runs li&#123;width:80px; height:80px; background:#06c; list-style:none; float:left; margin:10px; display:inline; filter:alpha(opacity=30); opacity:0.3;&#125;&lt;/style&gt;&lt;script&gt;window.onload = function()&#123; var runs = document.getElementById("runs"); var runs_li = runs.getElementsByTagName("li"); var i=0; for(i=0; i&lt;runs_li.length; i++)&#123; runs_li[i].timer = null; runs_li[i].alpha = 30; runs_li[i].onmouseover = function()&#123; startrun(this,100); &#125; runs_li[i].onmouseout = function()&#123; startrun(this,30); &#125; &#125;&#125;function startrun(obj,target)&#123; clearInterval(obj.timer); obj.timer = setInterval(function()&#123; var speed = 0; if(target&gt;obj.alpha)&#123; speed = 5; &#125;else&#123; speed = -5; &#125; if(obj.alpha == target)&#123; clearInterval(obj.timer); &#125;else&#123; obj.alpha = obj.alpha + speed; obj.style.filter = "alpha(opacity="+obj.alpha+")"; obj.style.opacity = obj.alpha/100; &#125; &#125;,30)&#125;&lt;/script&gt;&lt;ul id="runs"&gt; &lt;li&gt;简&lt;/li&gt; &lt;li&gt;明&lt;/li&gt; &lt;li&gt;现&lt;/li&gt; &lt;li&gt;代&lt;/li&gt; &lt;li&gt;魔&lt;/li&gt; &lt;li&gt;法&lt;/li&gt;&lt;/ul&gt;]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hybrid应用开发入门]]></title>
    <url>%2F2016%2F09%2F27%2FHybrid%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言Hybrid应用说白了就是NativeAPP与WebAPP的混合开发， Native APP就是利用Android SDK开发的Android应用，而Web APP是利用WebView来呈现网页页面的应用，但是编写网页页面需要具备HTML5、JavaScript的知识，这种开发模式兼具良好的Native用户交互体验的优势与WebApp跨平台的优势。 Native与WebView的进行交互1.Native调用JS我们知道如果Native需要调用Js中的方法，只需要使用WebView:loadUrl();方法即可直接调用指定Js代码中的函数，如：1mWebView.loadUrl("javascript:setUserName('zhooker');"); 2.JS调用Native1.传统的JSInterface最普通的一种通信方式，就是使用Android原生的JavascriptInterface来进行js和java的通信。首先先看一段html代码1234567891011121314151617181920&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" dir="ltr"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;script type="text/javascript"&gt; function showToast(toast) &#123; javascript:control.showToast(toast); &#125; function log(msg)&#123; console.log(msg); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="toast" onClick="showToast('Hello world')" /&gt;&lt;/body&gt;&lt;/html&gt; 当我们点击了按钮之后，会调用JS的showToast(),并调用到control.showToast(),我们接着看一下java层的代码：123456789101112131415161718192021222324252627282930313233@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); webView = (WebView)findViewById(R.id.webView); WebSettings webSettings = webView.getSettings(); webSettings.setJavaScriptEnabled(true); webView.addJavascriptInterface(new JsInterface(), "control"); webView.loadUrl("file:///android_asset/interact.html");&#125;public class JsInterface &#123; @JavascriptInterface public void showToast(String toast) &#123; Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show(); log("show toast success"); &#125; public void log(final String msg)&#123; webView.post(new Runnable() &#123; @Override public void run() &#123; webView.loadUrl("javascript: log(" + "'" + msg + "'" + ")"); &#125; &#125;); &#125;&#125; 首先界面很简单，一个WebView。在对应的activity中做的事也就几件，首先打开js通道。12WebSettings webSettings = webView.getSettings();webSettings.setJavaScriptEnabled(true); 然后通过WebView的addJavascriptInterface方法去注入一个我们自己写的interface。可以看到这个interface我们给它取名叫control。这个就对应于刚才html代码中的control。1webView.addJavascriptInterface(new JsInterface(), "control"); 最后loadUrl。1webView.loadUrl("file:///android_asset/interact.html"); 但是使用这种方式你就要小心XSS攻击了，虽然这个漏洞已经在Android4.2上修复了，就是使用@JavascriptInterface这个注解。但是你得考虑兼容性啊，你不能保证，尤其在中国这样碎片化严重的地方，每个用户使用的都是4.2+的系统。所以基本上我们不会再利用Android系统为我们提供的addJavascriptInterface方法或者@JavascriptInterface注解来实现js和java的通信了。那怎么办呢？方法都是人想出来的嘛，下面让我们看解决方案。 2.JSBridge方式JSBridge，顾名思义，就是和js沟通的桥梁。其实这个技术在Android中已经不算新了，相信有些同学也看到过不少实现方案，这里说一种我的想法吧。首先先说思路，有经验的同学可能都知道Android的WebView中有一个WebChromeClient类，这个类其实就是用来监听一些WebView中的事件的，我们发现其中有三个这样的方法。 1234567891011121314@Overridepublic boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; return super.onJsPrompt(view, url, message, defaultValue, result);&#125;@Overridepublic boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; return super.onJsAlert(view, url, message, result);&#125;@Overridepublic boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123; return super.onJsConfirm(view, url, message, result);&#125; 这三个方法其实就对应于js中的alert(警告框)，comfirm(确认框)和prompt(提示框)方法，。比如我们可以在js脚本中调用alert方法，这样对应的就会走到WebChromeClient类的onJsAlert()方法中，我们就可以拿到其中的信息去解析，并且做java层的事情。在js中，alert和confirm的使用概率还是很高的，特别是alert，所以我们最好不要使用这两个通道，以免出现不必要的问题。所以我们可以通过重写WebView中WebChromeClient类的onJsPrompt()方法来进行js和java的通信。我们可以定义一个自己的协议，通过js脚本把这段协议文本传递到onPropmt()方法中并且进行解析，在onPropmt()解析对应的URL之后就可以去执行对应的java代码了。一般URL的格式为：scheme://host:port/path?query，对应的我们协定prompt传入message的格式为: jsbridge://class:port/method?params。先看一下我们html和js的代码1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="file:///android_asset/jsBridge.js" type="text/javascript"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="blog-header"&gt; &lt;h3&gt;JSBridge&lt;/h3&gt;&lt;/div&gt;&lt;ul class="entry"&gt; &lt;br/&gt; &lt;li&gt; toast展示&lt;br/&gt; &lt;button onclick="JsBridge.call('JSBridge','toast',&#123;'message':'我是气泡','isShowLong':0&#125;,function(res)&#123;&#125;);"&gt;toast&lt;/button&gt; &lt;/li&gt; &lt;br/&gt; &lt;li&gt; 异步任务&lt;br/&gt; &lt;button onclick="JsBridge.call('JSBridge','plus',&#123;'data':1&#125;,function(res)&#123;console.log(JSON.stringify(res))&#125;);"&gt;plus&lt;/button&gt; &lt;/li&gt; &lt;br/&gt; &lt;br/&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 点击按钮会执行js脚本的这段代码12345678910111213call: function (obj, method, params, callback, timeout) &#123; var sid; if (typeof callback !== 'function') &#123; callback = null; &#125; sid = Private.getSid(); Private.registerCall(sid, callback); Private.callMethod(obj, method, params, sid);&#125; 然后在call这个方法内，会执行Private类的registerCall和callMethod，我们来看callMehod()。12345678910//生成URI，调用native功能callMethod: function (obj, method, params, sid) &#123; // hybrid://objectName:sid/methodName?params params = Private.buildParam(params); var uri = LOCAL_PROTOCOL + '://' + obj + ':' + sid + '/' + method + '?' + params; var value = CB_PROTOCOL + ':'; window.prompt(uri, value);&#125; 以界面的第一个按钮toast为例，点击这个按钮，它会执行相应的js脚本代码，然后就会像我们前面所讲的那样，走到onJsPrompt()方法中，下面让我们看看对应的java代码。123456789101112131415public class InjectedChromeClient extends WebChromeClient &#123; private final String TAG = "InjectedChromeClient"; private JsCallJava mJsCallJava; public InjectedChromeClient() &#123; mJsCallJava = new JsCallJava(); &#125; @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; result.confirm(mJsCallJava.call(view, message)); return true; &#125;&#125; 我们传给JsCallJava类的那个message，就像我们前面定义的协议一样。sheme是hybrid://，表示这是一个hybrid方法，host是JSBridge，方法名字是toast，传递的参数是以json格式传递的，具体内容如图。不知道大家有没有发现，这里我有一个东西没有讲，就是JSBridge:后面的那串数字，这串数字是干什么用的呢？大家应该知道，现在我们整个调用过程都是同步的，这意味着我们没有办法在里面做一些异步的操作，为了满足异步的需求，我们就需要定义这样的port，有了这串数字，我们在java层就可以做异步的操作，等操作完成以后回调给js脚本，js脚本就通过这串数字去得到对应的callback，有点像startActivity中的那个requestCode。Java层通过onJsPrompt获取到URl后，URL形式如hybrid://JSBridge:875725/toast?{“message”:”我是气泡”,”isShowLong”:0},就可以通过解析URL，再通过反射的方法去调用对应的函数。最后总结一下JSBridge的流程： 在js脚本中把对应的方法名，参数等写成一个符合协议的uri，并且通过window.prompt方法发送给java层。 在java层的onJsPrompt方法中接受到对应的message之后，通过JsCallJava类进行具体的解析。 在JsCallJava类中，我们解析得到对应的方法名，参数等信息，并且在map中查找出对应的类的方法。参考文章 Native与H5交互的那些事 好好和h5沟通！几种常见的hybrid通信方式 源码 RainbowBridge]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>Hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava使用指南]]></title>
    <url>%2F2016%2F09%2F11%2FRxJava%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言RxJava的开发模式越来越受开发者欢迎，响应式的编程不仅可以减少代码量，还增加了代码的可读性，让开发维护再加简单。RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。 一.什么是RxJavaRxJava其实就是一个工具库，使用的就是通用形式的观察者模式。RxJava最核心的两个东西是Observables（被观察者，事件源）和Subscribers（观察者）。Observables发出一系列事件，Subscribers处理这些事件。这里的事件可以是任何你感兴趣的东西（触摸事件，web接口调用返回的数据。。。）一个Observable可以发出零个或者多个事件，知道结束或者出错。每发出一个事件，就会调用它的Subscriber的onNext方法，最后调用Subscriber.onComplete()或者Subscriber.onError()结束。Rxjava的看起来很想设计模式中的观察者模式，但是有一点明显不同，那就是如果一个Observerble没有任何的的Subscriber，那么这个Observable是不会发出任何事件的。 二.为什么要用RxJavaRxJava 优点主要是让代码简洁，增加代码的可读性，随着程序逻辑变得越来越复杂，它依然能够保持简洁。我们想你一下这么一个场景：我们要从外部存储器中加载一张图片，并把图片转化成Bitmap并显示到ImageView中，如果我们按照非RxJava的开发方式，我们就要先创建一个异步线程（Thread、AsyncTask等）用来执行耗时的图片加载任务，之后再在主线程新建一个Handler用来更新ImageView。大概的代码是这样实现的：12345678910111213new Thread() &#123; @Override public void run() &#123; super.run(); final Bitmap bitmap = getBitmapFromFile(file); getActivity().runOnUiThread(new Runnable() &#123; @Override public void run() &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); &#125;&#125;.start(); 而如果使用 RxJava ，实现方式是这样的：123456789101112131415Observable.from(folders) .map(new Func1&lt;File, Bitmap&gt;() &#123; @Override public Bitmap call(File file) &#123; return getBitmapFromFile(file); &#125; &#125;) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Bitmap&gt;() &#123; @Override public void call(Bitmap bitmap) &#123; imageCollectorView.addImage(bitmap); &#125; &#125;); 虽然代码量并没有减少，但是用了RxJava之后代码的逻辑会很清晰， RxJava 的这个实现，是一条从上到下的链式调用，没有任何嵌套，这在逻辑的简洁性上是具有优势的。当需求变得复杂时，这种优势将更加明显。假设你要加载10张图片，并且只加载png格式的，加载完还要切割成圆角，在非RxJava的实现上，势必会添加10张图的循环嵌套，再增加一个isPNG()的判断函数，一个圆角切割函数toRoundBitmap(),势必会对代码逻辑一个大修改，而使用RxJava，我们只需要在链式调用上添加必要的处理函数就行了，添加代码如下：123456789101112131415161718.flatMap(new Func1&lt;File, Observable&lt;File&gt;&gt;() &#123; @Override public Observable&lt;File&gt; call(File file) &#123; return Observable.from(file.listFiles()); &#125; &#125;) .filter(new Func1&lt;File, Boolean&gt;() &#123; @Override public Boolean call(File file) &#123; return file.getName().endsWith(".png"); &#125; &#125;).map(new Func1&lt;Bitmap, Bitmap&gt;() &#123; @Override public Bitmap call(Bitmap origin) &#123; return toRoundBitmap(origin); &#125; &#125;) 特别是如果你的 IDE 是 Android Studio ，其实每次打开某个 Java 文件的时候，你会看到被自动 Lambda 化的预览，这将让你更加清晰地看到程序逻辑。 三.如何使用RxJava1.添加依赖库 compile &#39;io.reactivex:rxjava:1.1.6&#39; compile &#39;io.reactivex:rxandroid:1.2.1&#39; RxAndroid 是RxJava在Android运行环境的补充库。 1.创建 Observer1234567891011121314Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onNext(String s) &#123; Log.d(tag, "Item: " + s); &#125; @Override public void onCompleted() &#123; Log.d(tag, "Completed!"); &#125; @Override public void onError(Throwable e) &#123; Log.d(tag, "Error!"); &#125;&#125;; onCompleted() : 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 onNext() 发出时，需要触发 onCompleted() 方法作为标志。 onError() : 事件队列异常。在事件处理过程中出异常时，onError() 会被触发，同时队列自动终止，不允许再有事件发出。在一个正确运行的事件序列中, onCompleted() 和 onError()有且只有一个，并且是事件序列中的最后一个。需要注意的是，onCompleted() 和 onError() 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。 除了 Observer 接口之外，RxJava 还内置了一个实现了 Observer 的抽象类：Subscriber。 Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的。选择 Observer 和 Subscriber 是完全一样的。它们的区别对于使用者来说主要有两点： onStart(): 这是 Subscriber 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， onStart() 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 doOnSubscribe() 方法，具体可以在后面的文中看到。 unsubscribe(): 这是 Subscriber 所实现的另一个接口 Subscription 的方法，用于取消订阅。在这个方法被调用后，Subscriber 将不再接收事件。一般在这个方法调用前，可以使用 isUnsubscribed() 先判断一下状态。 unsubscribe() 这个方法很重要，因为在subscribe() 之后， Observable 会持有 Subscriber 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 onPause() onStop() 等方法中）调用 unsubscribe() 来解除引用关系，以避免内存泄露的发生。 2.创建 ObservableObservable 即被观察者，它决定触发事件的逻辑，即什么时候调用onNext，什么时候调用onComplete。 RxJava 使用 create() 方法来创建一个 Observable ，并为它定义事件触发规则：123456789Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext("Hello"); subscriber.onNext("Hi"); subscriber.onNext("Aloha"); subscriber.onCompleted(); ]\ &#125;&#125;); RxJava 还提供了一些方法用来快捷创建事件队列，例如：just(T...): 将传入的参数依次发送出来。123456Observable observable = Observable.just("Hello", "Hi", "Aloha");// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted(); from(T[]) / from(Iterable&lt;? extends T&gt;): 将传入的数组或 Iterable 拆分成具体对象后，依次发送出来。1234567String[] words = &#123;"Hello", "Hi", "Aloha"&#125;;Observable observable = Observable.from(words);// 将会依次调用：// onNext("Hello");// onNext("Hi");// onNext("Aloha");// onCompleted(); 3. Subscribe (订阅)创建了 Observable 和 Observer 之后，再用 subscribe() 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：12observable.subscribe(observer);// 或者：observable.subscribe(subscriber); 订阅之后 ，将会依次输出 “Item: Hello”, “Item: Hi”, “Item: Aloha” , “Completed!”。 4.线程控制 Scheduler默认情况下，即在没有任务设置的时候，Observable和Observer都在同一线程中执行，即创建了这两个对象的线程，相当于设置了Schedulers.immediate()。如果想在异步线程中执行，就要设置成Schedulers.newThread()或Schedulers.io() , 他们两个的区别是io()的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，而Schedulers.newThread() 总是启用新线程，并在新线程执行操作因此多数情况下io()比 newThread()更有效率。不要把计算工作放 io() 中，可以避免创建不必要的线程。 subscribeOn: 设置OnSubscribe运行的线程 observeOn: 设置Observer运行的线程 5.常用函数解析 map : 是转化成另一个类型的输出 compose : 也是一个转化，传的是一个Transformer,可以转化为Obserables添加参数，这个是高级的转化，不像flatmap,如果Obserables传的是数组，那会一个一个传，而compose会直接传数组。 filter : 过滤 interval , timer : 定时执行任务 delay ： 延时发送结果 5.在什么场景下使用RxJava 可以用Observable.concat(memory, disk, network).first(new Fun1(){}) 实现类似事件拦截机制。比如取数据先检查缓存的场景。注意此时的onCompleted只会调用一次。 可以用Observable.merge(observable1, observable2) 实现需要等到多个接口并发取完数据，再更新的情况。注意此时的onCompleted只会调用一次。 flatmap 主要转化成另一个Obserables，可以用flatmap实现一个接口的请求依赖另一个API请求返回的数据的场景。比如我们从网络获取到的列表，还要从本地数据库中取得缓存的列表，对比后再刷新出来。利用flatmap还能创建出更多嵌套的代码，而保持代码的简洁性，还有比如我们从SD搜索图片并加载成Bitmap，就可以用flatmap对每个子目录再搜索。 可以用filter、map执行一些复杂的数据变换。 参考文章 RxJava使用场景小结 给 Android 开发者的 RxJava 详解]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
</search>